[{"id":"071e075cf4eb65abed3b589cda67a89f","title":"PVE 虚拟环境下 LEDE 软路由&黑群晖一体机搭建踩坑实录","content":"\n\n\n\n\n\n\n\n\n奇怪的运营商司马增加了\n本文主要记录了在一台老 Intel 笔记本上安装 PVE 系统，部署 LEDE 软路由（主路由）以及黑群晖的瞎折腾过程。\n\n整个网络结构的规划为：光纤 -&gt; 光猫（桥接）-&gt; 交换机（有线终端接入）-&gt; 无线 AP（无线终端接入）-&gt; PVE Linux Bridge -&gt; LEDE 软路由 -&gt; 黑群晖 NAS。\nPVE 安装在 Proxmox 网站获取最新的镜像文件，使用 Rufus 刷写到 U 盘中，刷写模式选择 DD（否则会提示找不到启动设备）。\n写入完成以后拨下U盘，拿到安装 PVE 的主机上插入 USB 口，开机进 BIOS，确认 VT-D 已经开启，选U盘启动（UEFI方式）。\n第一次启动翻车第一次启动时出现了如下情况：\nerror:unknown filesystem\nerror:unknown filesystem\nerror:unknown filesystem\n...\ngrub rescue&gt;\n\n这是由于 grub 版本不匹配导致的，可以试着用 Rufus 重新刷写一遍更新 grub，或者输入以下指令。\ngrub rescue&gt;ls  #查看分区\ngrub rescue&gt;ls(hd0,...)  #如果依旧是 unknown filesystem 则换下一个分区\n...\ngrub rescue&gt;ls(hd1,...)  #找到了\n#修改启动分区\ngrub rescue&gt;root&#x3D;hd1,...    #分区名\ngrub rescue&gt;prefix&#x3D;&#x2F;boot&#x2F;grub\ngrub rescue&gt;set root&#x3D;(hd1,...)\ngrub rescue&gt;insmod normal\n\ngrub rescue&gt;normal  #进入启动菜单，按 C 进入命令行\ngrub&gt;set root&#x3D;hd1,...    #分区名\ngrub&gt;set prefix&#x3D;(hd1,...)&#x2F;boot&#x2F;grub\ngrub&gt;linux &#x2F;vmlinuz root&#x3D;&#x2F;dev&#x2F;sda*\ngrub&gt;initrd &#x2F;initrd.img\ngrub&gt;boot\n\n等进入系统后修复 grub。\nsudo update-grub\n\n后续安装Proxmox 有很友好的界面安装过程，基本无脑下一步就行，但需要注意在IP、掩码、网关设置页填写与你连接终端在同一网段的 IP 地址，此地址也是之后登录控制台的地址。\n\nHostname 随意填写就行。\n安装完成后，拔下 U 盘，重启即可。\n启动以后就会出现登陆信息提示，也就是控制台的 URL 访问地址，你可以用另外一台局域网内的电脑输入这个 URL 即能访问 PVE 的控制台：\n比如我的是：https://192.168.1.100:8006（记住是https而不是http）\n关于更改 PVE 主机的 IP 地址用 SSH 连接到 PVE 主机，输入\nvi &#x2F;etc&#x2F;network&#x2F;interfaces\n\n修改文件中的 address 和 gateway。\n保存退出，输入\nvi &#x2F;etc&#x2F;issue\n\n修改文件中 https://新IP:8006。\n保存退出，输入\nvi &#x2F;etc&#x2F;hosts\n\n修改第 2 行的 IP 地址，保存退出，重启即可。\n关于笔记本下 PVE 盒盖自动休眠编辑 /etc/systemd/logind.conf\n#HandlePowerKey按下电源键后的行为，默认power off\n#HandleSleepKey 按下挂起键后的行为，默认suspend\n#HandleHibernateKey按下休眠键后的行为，默认hibernate\n#HandleLidSwitch合上笔记本盖后的行为，默认suspend（改为ignore；即合盖不休眠）在原文件中，还要去掉前面的#\n\n重启服务\nservice systemd-logind restart\n\n安装 LEDE/OpenWrt 软路由创建虚拟机进入 PVE 控制台，点击“创建虚拟机”按钮，勾上“高级”，勾上“开机自启动”（软路由一般情况下开机启动），名称填入虚拟机名称（例如 LEDE），点击“下一步”。\n\n操作系统选择“Linux”，版本选择“4.X/3.X/2.6 Kernel”即可，选择“不适用任何介质”，点击“下一步”。\n\n硬盘默认即可，CPU按实际情况分配，内存512MB 即可。\n网络页确认桥接的设备是否正确，模型选择“VirtIO (半虚拟化)”（注意此网卡在 LEDE 界面中不会被正确识别，但实际是能够使用的），关闭防火墙（勾去掉），点击“下一步”。\n\n确认页确认无误，点击“完成”。\n删除不需要的硬件选择“LEDE” –&gt; “硬件”，找到默认创建的硬盘，选中点击“分离”。\n\n硬盘分离后，选中未使用的磁盘0，点击“删除”。\n\n同样的方法，也可将光驱删除掉（删除光驱不需要分离）。\n安装系统在 Koolshare 论坛获取 .gz 格式的文件，用 7-zip 解压，得到 .img 镜像文件，使用 SFTP 将镜像文件上传到 PVE 的 root 根目录。\n将 .img 的 RAW 文件转换为 qcow2 格式的文件，并添加到磁盘。（也可以 .img 文件直接添加到磁盘中，磁盘性能会有增加，但不能使用快照之类虚拟机相关的功能）\nqemu-img convert -f raw -O qcow2 *.img *.qcow2\nqemu-img check *.qcow2  #检查文件完整\nqm importdisk 100 *.qcow2 local-lvm  #添加到磁盘，100为对应的虚拟机编号\n\n选择“LEDE” –&gt; “硬件”，双击“未使用的磁盘0”，选择总线/设备为 SATA，点击“添加”。\n顺便再添加一个网口，点击左上“添加”选项卡，选择“网络设备”，模型选择“VirtIO (半虚拟化)”，点击“添加”。\n\n选择“LEDE” –&gt; “选项”，修改启动顺序第一为硬盘启动。\n\n至此虚拟机系统安装结束。\n启动与配置启动虚拟机，点击“控制台”。\n\n修改网络配置文件，输入\nvi &#x2F;etc&#x2F;config&#x2F;network\n\n重启网络\n&#x2F;etc&#x2F;init.d&#x2F;network restart\n\n在浏览器端通过配置后的 IP 地址登录路由器，默认密码 koolshare。\n若要配置软路由为旁路由，参考此处。\n若要给软路由手动挂载硬盘，并开启 smb 服务，参考此处。\n光猫改桥接登录光猫后台，按下图配置新建一个 WAN 连接。\n\n关闭 DHCP，发送短信到10086重置宽带密码即可。\n安装黑群晖创建虚拟机进入 PVE 控制台，点击“创建虚拟机”按钮，勾上“高级”，勾上“开机自启动”（软路由一般情况下开机启动），名称填入虚拟机名称（例如 DSM），点击“下一步”。\n\n操作系统选择“Linux”，版本选择“4.X/3.X/2.6 Kernel”即可，选择“不适用任何介质”，点击“下一步”。\n\n硬盘默认即可，CPU按实际情况分配，内存2GB 足够，也可按实际情况增加到8 GB。\n网络页确认桥接的设备是否正确，模型选择“Intel E1000”（半虚拟化网卡会导致无法连接到 NAS），关闭防火墙（勾去掉），点击“下一步”。\n确认页确认无误，点击“完成”。\n删除不需要的硬件选择“LEDE” –&gt; “硬件”，找到默认创建的硬盘，选中点击“分离”。\n\n硬盘分离后，选中未使用的磁盘0，点击“删除”。\n\n同样的方法，也可将光驱删除掉（删除光驱不需要分离）。\n注意：如果要拆掉已部署好的虚拟机 NAS 硬盘，先在 PVE 控制台中将硬盘分离，再将硬盘从机器上拆下，以免虚拟机无法进入系统。\n注入引导准备好引导文件和对应系统（.pat）文件，将 .img 的 RAW 引导文件转换为 qcow2 格式的文件，并添加到磁盘。（也可以 .img 文件直接添加到磁盘中，磁盘性能会有增加，但不能使用快照之类虚拟机相关的功能）\nqemu-img convert -f raw -O qcow2 *.img *.qcow2\nqemu-img check *.qcow2  #检查文件完整\nqm importdisk 101 *.qcow2 local-lvm  #添加到磁盘，101为对应的虚拟机编号\n\n选择“硬件”，双击“未使用的磁盘0”，选择总线/设备为 SATA，点击“添加”。\n选择“选项”，修改启动顺序第一为硬盘 sata0 启动。\n硬盘直通搜索要直通硬盘的名字\nls -l &#x2F;dev&#x2F;disk&#x2F;by-id&#x2F;\n\ntotal 0\nlrwxrwxrwx 1 root root  9 Feb 18 15:22 ata-ADATA_SU600_2H2920059140 -&gt; ..&#x2F;..&#x2F;sda\nlrwxrwxrwx 1 root root 10 Feb 18 15:22 ata-ADATA_SU600_2H2920059140-part1 -&gt; ..&#x2F;..&#x2F;sda1\nlrwxrwxrwx 1 root root 10 Feb 18 15:22 ata-ADATA_SU600_2H2920059140-part2 -&gt; ..&#x2F;..&#x2F;sda2\nlrwxrwxrwx 1 root root 10 Feb 18 17:43 ata-ADATA_SU600_2H2920059140-part3 -&gt; ..&#x2F;..&#x2F;sda3\nlrwxrwxrwx 1 root root  9 Feb 20 09:48 ata-HL-DT-ST_DVDRAM_GUA0N_M3HDBE92146 -&gt; ..&#x2F;..&#x2F;sr0\nlrwxrwxrwx 1 root root 10 Feb 18 15:22 dm-name-pve-root -&gt; ..&#x2F;..&#x2F;dm-1\nlrwxrwxrwx 1 root root 10 Feb 18 15:22 dm-name-pve-swap -&gt; ..&#x2F;..&#x2F;dm-0\nlrwxrwxrwx 1 root root 10 Feb 18 15:22 dm-name-pve-vm--100--disk--0 -&gt; ..&#x2F;..&#x2F;dm-6\nlrwxrwxrwx 1 root root 10 Feb 21 10:44 dm-name-pve-vm--101--disk--0 -&gt; ..&#x2F;..&#x2F;dm-7\nlrwxrwxrwx 1 root root 10 Feb 18 15:22 dm-uuid-LVM-Y6rOQSEmx7NnZGSxyFMCeQuQZMV4j8cT3vbIcOrPhnw3uBZEDn5Lddpq3bAhtCyA -&gt; ..&#x2F;..&#x2F;dm-1\nlrwxrwxrwx 1 root root 10 Feb 18 15:22 dm-uuid-LVM-Y6rOQSEmx7NnZGSxyFMCeQuQZMV4j8cTf2hYrl4cwr7Keb4NjQyQHm2TwT5uNKCk -&gt; ..&#x2F;..&#x2F;dm-6\nlrwxrwxrwx 1 root root 10 Feb 18 15:22 dm-uuid-LVM-Y6rOQSEmx7NnZGSxyFMCeQuQZMV4j8cThddROH8Cwqq1WN2qZIdA76EY5xBPF0b6 -&gt; ..&#x2F;..&#x2F;dm-0\nlrwxrwxrwx 1 root root 10 Feb 21 10:44 dm-uuid-LVM-Y6rOQSEmx7NnZGSxyFMCeQuQZMV4j8cTmUj5qVbEQBOnbVbxql3ZPDVy8ho3fmVU -&gt; ..&#x2F;..&#x2F;dm-7\nlrwxrwxrwx 1 root root 10 Feb 18 17:43 lvm-pv-uuid-Zkz9vg-u9rg-lztZ-mkgI-EsLe-1zs8-ayPXHo -&gt; ..&#x2F;..&#x2F;sda3\nlrwxrwxrwx 1 root root  9 Feb 21 08:03 usb-Seagate_BUP_Slim_GD_NA7YCVF6-0:0 -&gt; ..&#x2F;..&#x2F;sdc\nlrwxrwxrwx 1 root root 10 Feb 21 08:03 usb-Seagate_BUP_Slim_GD_NA7YCVF6-0:0-part1 -&gt; ..&#x2F;..&#x2F;sdc1\nlrwxrwxrwx 1 root root 10 Feb 21 08:03 usb-Seagate_BUP_Slim_GD_NA7YCVF6-0:0-part2 -&gt; ..&#x2F;..&#x2F;sdc2\nlrwxrwxrwx 1 root root 10 Feb 21 08:03 usb-Seagate_BUP_Slim_GD_NA7YCVF6-0:0-part3 -&gt; ..&#x2F;..&#x2F;sdc3\nlrwxrwxrwx 1 root root 10 Feb 21 08:03 usb-Seagate_BUP_Slim_GD_NA7YCVF6-0:0-part5 -&gt; ..&#x2F;..&#x2F;sdc5\nlrwxrwxrwx 1 root root  9 Feb 20 09:48 wwn-0x5001480000000000 -&gt; ..&#x2F;..&#x2F;sr0\nlrwxrwxrwx 1 root root  9 Feb 18 15:22 wwn-0x5707c1810054afc4 -&gt; ..&#x2F;..&#x2F;sda\nlrwxrwxrwx 1 root root 10 Feb 18 15:22 wwn-0x5707c1810054afc4-part1 -&gt; ..&#x2F;..&#x2F;sda1\nlrwxrwxrwx 1 root root 10 Feb 18 15:22 wwn-0x5707c1810054afc4-part2 -&gt; ..&#x2F;..&#x2F;sda2\nlrwxrwxrwx 1 root root 10 Feb 18 17:43 wwn-0x5707c1810054afc4-part3 -&gt; ..&#x2F;..&#x2F;sda3\n\nSATA 硬盘前缀为 ata，USB 硬盘前缀为 usb，这里以直通1T 希捷移动硬盘为例，查询到硬盘目录为 usb-Seagate_BUP_Slim_GD_NA7YCVF6-0:0，输入命令\nqm set 101 -sata1 &#x2F;dev&#x2F;disk&#x2F;by-id&#x2F;usb-Seagate_BUP_Slim_GD_NA7YCVF6-0:0  #101为直通虚拟机编号\n\n便会自动给 101 号虚拟机添加一块编号 sata1 的硬盘。\n安装系统启动虚拟机，待控制台中显示\n\n在浏览器输入网址 find.synology.com，执行系统初始化。\n\n\n选择手动安装，选择对应的系统文件，过几分钟后就会自动进入 NAS 的主界面。\n\n","slug":"PVE虚拟环境LEDE软路由-黑群晖一体机搭建踩坑实录","date":"2020-02-21T11:57:07.000Z","categories_index":"技术","tags_index":"网络技术","author_index":"Ryanhui"},{"id":"a71e8b888458c8851815d0b96809bb00","title":"训练深度学习网络的挑战和解决方法","content":"Hands-on ml2 Ch.11 读书笔记。\n\nVanishing/Exploding Gradients在深度学习网络训练过程中，更深层次的网络梯度下降幅度越小，导致深层次的网络权重保持不变。或一些层梯度过大，每次权值更新的幅度很大（如 RNN）。导致不同层的学习速度相差较大。\n这个问题的出现可归功于 Sigmoid 激活函数和正态分布权值初始化方法的使用。由于 Sigmoid 激活函数在正无穷和负无穷处收敛，其导数趋向于 0。\nGlorot and He Initialization因此，建议在使用 Sigmoid 激活函数时采用 Glorot 初始化权值，或使用 ReLU 激活函数时采用 He 初始化权值，以及使用 SELU 激活函数时采用 LeCun 初始化权值。\nKeras 默认使用正态分布的 Glorot 初始化权值。\n不收敛的激活函数在深度学习网络中使用 ReLU 激活函数的效果比 Sigmoid 激活函数好很多。但会出现 dying ReLUs 的问题：一些神经元的激活值一直为0。\n可以使用 leaky ReLU 函数解决这个问题 。即引入一个超参数  定义当输入值  时函数的“泄露量”。Randomized leaky ReLU(RReLU) 是 leaky ReLU 的变种，即在训练过程中随机指定某一范围内的  值，测试时则取训练中  的平均值。\n2015年，exponential linear unit（ELU）激活函数被提出。后来，有人提出在只由 dense 层构建的神经网络中使用 SELU 函数（S for scale），网络会 self-normalize：训练过程中，每一层的输出会保持平均值为0，标准差为1，即不会出现 Vanishing/Exploding Gradients。但出现这种现象需要一定条件：\n\n输入层必须是正则的（均值为0，标准差为1）；\n每个隐藏层的权值必须是 LeCun 初始化；\n网络的架构必须是连续的，例如在 RNN 中 SELU 的效果就不如其他激活函数；\n必须是只由 dense 层构建的神经网络，然而实际 SELU 在 CNN 中的效果也很好。\n\n因此选择激活函数：SELU&gt;ELU&gt;leaky ReLU（及其变种）&gt;ReLU&gt;tanh&gt;logistic(sigmoid)。如果网络不是 self-normalize 的，ELU 的效果会比 SELU 更佳。如果不考虑运行延迟，可以选用 leaky ReLU。不想调参可以用 Keras 使用的  值（0.3）。算力允许的话，也可以使用交叉验证寻找其他激活函数，比如过拟合时考虑用 RReLU，训练集较大时用 PReLU。\nBatch NormalizationBatch normalization 可以降低网络在训练过程中出现 Vanishing/Exploding Gradients 的几率。即在每个隐藏层的激活函数之前或之后加一层处理，将输入值归一化和偏移。\n但 Batch normalization 会增加计算量，因此需要加速训练的话，还是先考虑 ELU+He 初始化权值是否有用。\n使用训练好的神经层可以寻找一个已经训练好的神经网络，并使用该网络的底层加速我们的训练，此方法也被称为迁移学习。\n首先冻结所有的神经网络层，在此网络上进行训练，并评估其表现。之后解冻最顶部（靠近输出）的一到两层，使用向后传播对其参数微调，评估网络性能是否有改进。使用的训练数据越多，可解冻的层数可以相应增加。注意在解冻层时适当减小学习率，这样可以最大程度避免对原始参数的扰动。\n如果使用了上述方法但没有明显效果，且可用于训练的数据较少，可以尝试去掉顶部的层，并重复上述方法训练，直到找到适合的网络结构为止。\nDropout在每一个训练步前，网络中所有的神经元（包含输入层，但往往不包含输出层）均有一定几率  暂时不参与此训练步（指被完全忽略，并非“冻结”），但在下一个训练步中有可能被再次激活。 为超参数，称为 dropout rate。\n此时，每一次训练的网络结构都有所不同，因此最后的训练结果可视为这些网络的整体代表。\n一般 Dropout 仅参与到训练过程中，因此训练损失会有所高于验证损失，直接比较二者是有失妥当的。\n","slug":"训练深度学习网络的挑战和解决方法","date":"2019-12-27T09:46:48.000Z","categories_index":"笔记","tags_index":"读书笔记,深度学习","author_index":"Ryanhui"},{"id":"b7638511be4b1096798ab59fb8661e33","title":"HTML-动手学（7）","content":"Codecademy HTML 教程学习笔记\n\nForms（表单）\nHow a Form Works（表单是如何工作的）使用 &lt;form&gt; 元素创建表单。\n&lt;form action&#x3D;&quot;&#x2F;example.html&quot; method&#x3D;&quot;POST&quot;&gt;\n&lt;&#x2F;form&gt;\n\n在上述代码中，我们创建了一个表单的框架。\n该表单将使用 POST 请求将信息发送至 example.html。\n其中：\n\naction 属性指定了信息发送的位置。\nmethod 属性指定了发送信息使用的 HTTP 请求（注意：HTTP 请求对大小写不敏感，此处使用 post 替代，二者的效果是相同的）\n\n&lt;form&gt; 元素中也可包含子元素，例如给表单添加名称。\n&lt;form action&#x3D;&quot;&#x2F;example.html&quot; method&#x3D;&quot;POST&quot;&gt;\n  &lt;h1&gt;Creating a form&lt;&#x2F;h1&gt;\n  &lt;p&gt;Looks like you want to learn how to create an HTML form. Well, the best way to learn is to play around with it.&lt;&#x2F;p&gt;\n&lt;&#x2F;form&gt;\n\nText Input（文字输入）使用 &lt;input&gt; 元素在表单中创建输入域。\n&lt;input&gt; 的 type 属性值决定了输入域在网页中的渲染方式以及接受的数据类型。\n&quot;text&quot; 值将在网页中渲染一个文字输入框，即type=&quot;text&quot;。此时还需加入 name 属性，否则输入的信息将不会被上传到网页。\n&lt;form action&#x3D;&quot;&#x2F;example.html&quot; method&#x3D;&quot;POST&quot;&gt;\n  &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;first-text-field&quot;&gt;\n&lt;&#x2F;form&gt;\n例如，当用户在此输入框中输入 “important details” \n\n当提交表单时，&quot;first-text-field=important details&quot; 会被上传至网页 /example.html。\n也可以定义 value 属性的值以向输入框中添加默认的输入信息。\n&lt;form action&#x3D;&quot;&#x2F;example.html&quot; method&#x3D;&quot;POST&quot;&gt;\n  &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;first-text-field&quot; value&#x3D;&quot;already pre-filled&quot;&gt;\n&lt;&#x2F;form&gt;\n\n\n  \n\n\nForm Validation（Form 验证）\nForm 具有多种验证方式：\n\n服务器端验证\n客户端验证\n\n","slug":"HTML-动手学（7）","date":"2019-10-16T11:12:59.000Z","categories_index":"动手学,HTML","tags_index":"动手学,HTML,前端开发","author_index":"Ryanhui"},{"id":"c935bdf3f887485f5023b578ad557d36","title":"HTML-动手学（6）","content":"Codecademy HTML 教程学习笔记\n\n提要\nTABLES（表格）Create a Table（创建表格）使用 &lt;table&gt; 元素创建表格。\n&lt;table&gt;\n\n&lt;&#x2F;table&gt;\n\nTable Rows（行）使用表格行（table row）元素 &lt;tr&gt; 向表格中添加行。\n&lt;table&gt;\n  &lt;tr&gt;\n  &lt;&#x2F;tr&gt;\n  &lt;tr&gt;\n  &lt;&#x2F;tr&gt;\n&lt;&#x2F;table&gt;\n\nTable Data（表格数据）使用表格数据（table data）元素 &lt;td&gt; 向表格中添加数据。\n&lt;table&gt;\n  &lt;tr&gt;\n    &lt;td&gt;73&lt;&#x2F;td&gt;\n    &lt;td&gt;81&lt;&#x2F;td&gt;\n  &lt;&#x2F;tr&gt;\n&lt;&#x2F;table&gt;\n\nTable Headings（表索引）使用表索引（table Headings）元素 &lt;th&gt; 向表格中添加表索引。\n&lt;table&gt;\n  &lt;tr&gt;\n    &lt;th&gt;&lt;&#x2F;th&gt;\n    &lt;th scope&#x3D;&quot;col&quot;&gt;Saturday&lt;&#x2F;th&gt;\n    &lt;th scope&#x3D;&quot;col&quot;&gt;Sunday&lt;&#x2F;th&gt;\n  &lt;&#x2F;tr&gt;\n  &lt;tr&gt;\n    &lt;th scope&#x3D;&quot;row&quot;&gt;Temperature&lt;&#x2F;th&gt;\n    &lt;td&gt;73&lt;&#x2F;td&gt;\n    &lt;td&gt;81&lt;&#x2F;td&gt;\n  &lt;&#x2F;tr&gt;\n&lt;&#x2F;table&gt;\n\n注意 &lt;th&gt; 的 scope 属性，该属性值可取以下两种之一：\n\nrow - 行索引\ncol - 列索引\n\nTable Borders（表格边框）在旧版的 HTML 中，可以通过在 &lt;tabel&gt; 中添加 border 属性来指定表格的边框。\n&lt;table border&#x3D;&quot;1&quot;&gt;\n  &lt;tr&gt;\n    &lt;td&gt;73&lt;&#x2F;td&gt;\n    &lt;td&gt;81&lt;&#x2F;td&gt;\n  &lt;&#x2F;tr&gt;\n&lt;&#x2F;table&gt;\n\n注意：上述代码已不在被使用，与此同时，应在对应的 CSS 样式表中指定表格边框的宽度。\ntable, td &#123;\n  border: 1px solid black;\n&#125;\n\nSpanning Columns（合并列）使用 colspan 属性合并列，其值为要合并的列数。\n&lt;table&gt;\n  &lt;tr&gt;\n    &lt;th&gt;Monday&lt;&#x2F;th&gt;\n    &lt;th&gt;Tuesday&lt;&#x2F;th&gt;\n    &lt;th&gt;Wednesday&lt;&#x2F;th&gt;\n  &lt;&#x2F;tr&gt;\n  &lt;tr&gt;\n    &lt;td colspan&#x3D;&quot;2&quot;&gt;Out of Town&lt;&#x2F;td&gt;\n    &lt;td&gt;Back in Town&lt;&#x2F;td&gt;\n  &lt;&#x2F;tr&gt;\n&lt;&#x2F;table&gt;\n\nSpanning Rows（合并行）使用 rowspan 属性合并行，其值为要合并的行数。\n&lt;table&gt;\n  &lt;tr&gt; &lt;!-- Row 1 --&gt;\n    &lt;th&gt;&lt;&#x2F;th&gt;\n    &lt;th&gt;Saturday&lt;&#x2F;th&gt;\n    &lt;th&gt;Sunday&lt;&#x2F;th&gt;\n  &lt;&#x2F;tr&gt;\n  &lt;tr&gt; &lt;!-- Row 2 --&gt;\n    &lt;th&gt;Morning&lt;&#x2F;th&gt;\n    &lt;td rowspan&#x3D;&quot;2&quot;&gt;Work&lt;&#x2F;td&gt;\n    &lt;td rowspan&#x3D;&quot;3&quot;&gt;Relax&lt;&#x2F;td&gt;\n  &lt;&#x2F;tr&gt;\n  &lt;tr&gt; &lt;!-- Row 3 --&gt;\n    &lt;th&gt;Afternoon&lt;&#x2F;th&gt;\n  &lt;&#x2F;tr&gt;\n  &lt;tr&gt; &lt;!-- Row 4 --&gt;\n    &lt;th&gt;Evening&lt;&#x2F;th&gt;\n    &lt;td&gt;Dinner&lt;&#x2F;td&gt;\n  &lt;&#x2F;tr&gt;\n&lt;&#x2F;table&gt;\n\nSaturdaySundayMorningWorkRelaxAfternoonEveningDinner\n\nTable Body（表体）使用表体（table body）元素 &lt;tbody&gt; 创建表体。\n&lt;tbody&gt; 元素应包含所有表格数据，但不包含表索引。\n&lt;table&gt;\n  &lt;tbody&gt;\n    &lt;tr&gt;\n      &lt;th&gt;&lt;&#x2F;th&gt;\n      &lt;th&gt;Saturday&lt;&#x2F;th&gt;\n      &lt;th&gt;Sunday&lt;&#x2F;th&gt;\n    &lt;&#x2F;tr&gt;\n    &lt;tr&gt;\n      &lt;th&gt;Morning&lt;&#x2F;th&gt;\n      &lt;td rowspan&#x3D;&quot;2&quot;&gt;Work&lt;&#x2F;td&gt;\n      &lt;td rowspan&#x3D;&quot;3&quot;&gt;Relax&lt;&#x2F;td&gt;\n    &lt;&#x2F;tr&gt;\n    &lt;tr&gt;\n     &lt;th&gt;Afternoon&lt;&#x2F;th&gt;\n    &lt;&#x2F;tr&gt;\n    &lt;tr&gt;\n      &lt;th&gt;Evening&lt;&#x2F;th&gt;\n      &lt;td&gt;Dinner&lt;&#x2F;td&gt;\n    &lt;&#x2F;tr&gt;\n  &lt;&#x2F;tbody&gt;\n&lt;&#x2F;table&gt;\n\n注意：此处 &lt;tbody&gt; 中包含有表索引，此问题会在下一节得到解决。\nTable Head（表头）使用 &lt;thead&gt; 元素在表格第一行创建表头。\n&lt;table&gt;\n  &lt;thead&gt;\n    &lt;tr&gt;\n      &lt;th&gt;&lt;&#x2F;th&gt;\n      &lt;th&gt;Saturday&lt;&#x2F;th&gt;\n      &lt;th&gt;Sunday&lt;&#x2F;th&gt;\n    &lt;&#x2F;tr&gt;\n  &lt;&#x2F;thead&gt;\n  &lt;tbody&gt;\n    &lt;tr&gt;\n      &lt;th&gt;Morning&lt;&#x2F;th&gt;\n      &lt;td rowspan&#x3D;&quot;2&quot;&gt;Work&lt;&#x2F;td&gt;\n      &lt;td rowspan&#x3D;&quot;3&quot;&gt;Relax&lt;&#x2F;td&gt;\n    &lt;&#x2F;tr&gt;\n    &lt;tr&gt;\n     &lt;th&gt;Afternoon&lt;&#x2F;th&gt;\n    &lt;&#x2F;tr&gt;\n    &lt;tr&gt;\n      &lt;th&gt;Evening&lt;&#x2F;th&gt;\n      &lt;td&gt;Dinner&lt;&#x2F;td&gt;\n    &lt;&#x2F;tr&gt;\n  &lt;&#x2F;tbody&gt;\n&lt;&#x2F;table&gt;\n\nTable Footer（页脚）使用 &lt;tfoot&gt; 元素在表格最后一行创建页脚。\n&lt;table&gt;\n  &lt;thead&gt;\n    &lt;tr&gt;\n      &lt;th&gt;Quarter&lt;&#x2F;th&gt;\n      &lt;th&gt;Revenue&lt;&#x2F;th&gt;\n      &lt;th&gt;Costs&lt;&#x2F;th&gt;\n    &lt;&#x2F;tr&gt;\n  &lt;&#x2F;thead&gt;\n  &lt;tbody&gt;\n    &lt;tr&gt;\n      &lt;th&gt;Q1&lt;&#x2F;th&gt;\n      &lt;td&gt;$10M&lt;&#x2F;td&gt;\n      &lt;td&gt;$7.5M&lt;&#x2F;td&gt;\n    &lt;&#x2F;tr&gt;\n    &lt;tr&gt;\n      &lt;th&gt;Q2&lt;&#x2F;th&gt;\n      &lt;td&gt;$12M&lt;&#x2F;td&gt;\n      &lt;td&gt;$5M&lt;&#x2F;td&gt;\n    &lt;&#x2F;tr&gt;\n  &lt;&#x2F;tbody&gt;\n  &lt;tfoot&gt;\n    &lt;tr&gt;\n      &lt;th&gt;Total&lt;&#x2F;th&gt;\n      &lt;td&gt;$22M&lt;&#x2F;td&gt;\n      &lt;td&gt;$12.5M&lt;&#x2F;td&gt;\n    &lt;&#x2F;tr&gt;\n  &lt;&#x2F;tfoot&gt;\n&lt;&#x2F;table&gt;\n\nStyling with CSS（使用 CSS 添加样式）使用 CSS 添加表格样式。\ntable, th, td &#123;\n  border: 1px solid black;\n  font-family: Arial, sans-serif;\n  text-align: center;\n&#125;","slug":"HTML-动手学（6）","date":"2019-10-15T11:31:19.000Z","categories_index":"动手学,HTML","tags_index":"动手学,HTML,前端开发","author_index":"Ryanhui"},{"id":"e6dde2807ee52a664613c6eb3fe249e0","title":"HTML-动手学（5）","content":"Codecademy HTML 教程学习笔记\n\nPreparing for HTML（准备 HTML 文件）在 HTML 文件开头插入代码\n&lt;!DOCTYPE html&gt;\n\n以表示此为 HTML5 文件。\nThe  tag（HTML 标识符）在 &lt;!DOCTYPE html&gt; 后加入 &lt;html&gt; 标识符，以创建 HTML 结构和内容。\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n\n&lt;&#x2F;html&gt;\n\nThe Head（开头）在 &lt;html&gt; 标识符后加入 &lt;head&gt; 标识符，向页面中添加元数据（在页面中无法直接展示的内容）\n&lt;head&gt;\n&lt;&#x2F;head&gt;\n\nPage Titles（页标题）在 &lt;head&gt; 中插入 &lt;title&gt; 标识符以定义页标题。\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;My Coding Journal&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n&lt;&#x2F;html&gt;\n\nLinking to Other Web Pages（连接到其他页面）通过添加锚元素 &lt;a&gt; ，创建一段文字的超链接。\n&lt;a&gt;This Is A Link To Wikipedia&lt;&#x2F;a&gt;\n\n定义超链接参考属性 herf 将该段文字链接到指定页面。\n&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.wikipedia.org&#x2F;&quot;&gt;This Is A Link To Wikipedia&lt;&#x2F;a&gt;\n\n链接到相邻页面如要访问同一根目录下的其他页面，如对于如下根目录：\nproject-folder&#x2F;\n|—— about.html\n|—— contact.html\n|—— index.html\n\n可以添加目标页面的相对路径到 href 值。\n&lt;a href&#x3D;&quot;.&#x2F;contact.html&quot;&gt;Contact&lt;&#x2F;a&gt;\n\nOpening Links in a New Window（在新窗口打开链接）通过 &lt;a&gt; 的 target 属性控制打开链接的行为。\n若要使链接在新窗口中打开，需要将 target 的值设为 _blank。\n&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Brown_bear&quot; target&#x3D;&quot;_blank&quot;&gt;The Brown Bear&lt;&#x2F;a&gt;\n\n注意：对于现代的浏览器，添加 target=&quot;_blank&quot; 属性会在新标签页中打开页面。\nLinking At Will（在各种内容中添加超链接）可以将任意 HTML 元素添加到锚元素中。\n&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Opuntia&quot; target&#x3D;&quot;_blank&quot;&gt;&lt;img src&#x3D;&quot;#&quot; alt&#x3D;&quot;A red prickly pear fruit&quot;&#x2F;&gt;&lt;&#x2F;a&gt;\n\nLinking to Same Page（链接到同一页面上的位置）首先在目标位置定义 id。\n&lt;p id&#x3D;&quot;top&quot;&gt;This is the top of the page!&lt;&#x2F;p&gt;\n&lt;h1 id&#x3D;&quot;bottom&quot;&gt;This is the bottom! &lt;&#x2F;h1&gt;\n\n此时在目标链接中定义 # +对应 id 的值，即可链接到相应位置。\n&lt;ol&gt;\n  &lt;li&gt;&lt;a href&#x3D;&quot;#top&quot;&gt;Top&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;\n  &lt;li&gt;&lt;a href&#x3D;&quot;#bottom&quot;&gt;Bottom&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;\n&lt;&#x2F;ol&gt;\n\nComments（注释）在 &lt;!-- 与 --&gt; 中间插入注释。\n&lt;!-- This is a comment that the browser will not display. --&gt;\n\n在Mozilla 文档查找更多的 HTML 标识符。\n","slug":"HTML-动手学（5）","date":"2019-10-14T12:33:48.000Z","categories_index":"动手学,HTML","tags_index":"动手学,HTML,前端开发","author_index":"Ryanhui"},{"id":"f68d9754919b32dedba42fbafa34963c","title":"HTML 动手学（4）","content":"Codecademy HTML 教程学习笔记\n\nImages（图片）使用 &lt;img&gt; 标识符向网页中添加图片。\n注意，&lt;img&gt; 是自闭合标识符，在 &lt;img&gt; 标识符后包含一条斜线 /。自闭合标识符后面的 / 可以忽略。\n&lt;img src&#x3D;&quot;image-location.jpg&quot; &#x2F;&gt;\n\n&lt;img&gt; 有一个必要的属性 src，src 即为图片源或图片的位置。此例中，src 的值应为图片的统一资源定位器（URL）地址。\nImages Alts（图片替代文字）&lt;img&gt; 的另一个属性 alt 可以为图片添加一段说明文字，其值便是说明文字的内容：\n&lt;img src&#x3D;&quot;#&quot; alt&#x3D;&quot;A field of yellow sunflowers&quot; &#x2F;&gt;\n\nalt 还有以下几个作用：\n\n图片加载失败时显示替代文字；\n一些软件可以为视力障碍读者朗诵图片替代文字的内容；\n便于搜索引擎搜索。\n\nalt 属性并非必须。\nVideo（视频）使用 &lt;video&gt; 标识符向网页中添加视频。\n&lt;video&gt; 有一个必要的属性 src，src 即为视频源或视频的位置。&lt;video&gt; 元素包含一个 &lt;video&gt; 开始符和一个 &lt;video&gt; 结束符。\n&lt;video src&#x3D;&quot;myVideo.mp4&quot; width&#x3D;&quot;320&quot; height&#x3D;&quot;240&quot; controls&gt;\n  Video not supported\n&lt;&#x2F;video&gt;\n\n在 src 属性之后，还包含 width 和 height 属性分别用于定义视频的长和宽。controls 属性表示添加必要的视频控件，如：暂停、播放和跳过等。\n&lt;video&gt; 标识符中间的文字在视频无法加载时会显示在网页上。\n","slug":"HTML-动手学（4）","date":"2019-10-10T07:02:02.000Z","categories_index":"动手学,HTML","tags_index":"动手学,HTML,前端开发","author_index":"Ryanhui"},{"id":"7bbd0dd3859c0d14236fdbde3c410ddb","title":"Javascript 动手学（1）- Javascript 简介","content":"Codecademy Javascript 教程学习笔记\n\nConsole（控制台）控制台为显示重要信息的面板，使用 console.log 方法将信息打印到控制台上。\nconsole.log(5); \n\n此处，分号表示一行的结尾。注意 Javascript 语言区分大小写。\nComments（注释）Javascript 中包含2种注释方式：\n\n单行注释：在注释行前插入双斜线 //。&#x2F;&#x2F; 输出 5 到控制台\nconsole.log(5);\n也可以在代码之后注释：console.log(5);  &#x2F;&#x2F; 输出 5 \n多行注释：在多行注释前插入 /*，在结尾处插入 */。&#x2F;*\n所有内容都被注释 \nconsole.log(10);\n没有一句代码会被运行！\nconsole.log(99);\n*&#x2F;\n也可以使用此语法将代码中的一部分注释掉：console.log(&#x2F;*无视!*&#x2F; 5);  &#x2F;&#x2F; 依然输出 5 \n\nData Types（数据格式）Javascript 包含7种基本数据格式：\n\nNumber（数字）。包含各种数字，包括小数：8，1516，23.42。\nString（字符串）。包含一组字符，用单引号 &#39;...&#39; 或双引号 &quot;...&quot; 括起来。\nBoolean（布尔值）。true 和 false。\nNull（空值）。代码中用 null 表示。\nUndefined（缺省值）。与 null 类似表示缺失的值，但用处不同。代码中用 undefined 表示。\nSymbol（标志）。包含特殊的标识符，通常用在复杂代码中。\nObject（对象）。\n\n前6种为基本数据结构。\nArithmetic Operators（数学运算符）Javascript 内建的数学运算符包含：\n\n加：+\n减：-\n乘：*\n除：/\n取余：%\n\nString Concatenation（连接字符串）使用 + 连接2个独立的字符串：\nconsole.log(&#39;hi&#39; + &#39;ya&#39;); &#x2F;&#x2F; 输出 &#39;hiya&#39;\nconsole.log(&#39;wo&#39; + &#39;ah&#39;); &#x2F;&#x2F; 输出 &#39;woah&#39;\nconsole.log(&#39;I love to &#39; + &#39;code.&#39;)\n&#x2F;&#x2F; 输出 &#39;I love to code.&#39;\n\n可以用多个运算符连接多个字符串：\nconsole.log(&#39;One&#39; + &#39;, &#39; + &#39;two&#39; + &#39;, &#39; + &#39;three!&#39;); \n&#x2F;&#x2F; 输出 &#39;One, two, three!&#39;\n\nProperties（属性）创建的字符串实例自带一个属性叫 length，即返回该字符串的长度：\nconsole.log(&#39;Hello&#39;.length); &#x2F;&#x2F; 输出 5\n\nMethods（方法）字符串实例自带的其中两个方法包括 .toUpperCase()（将所有字符转换为大写，返回一个字符串）和 .startsWith()（检测字符串的起始字符，返回一个布尔值）：\nconsole.log(&#39;hello&#39;.toUpperCase()); &#x2F;&#x2F; 输出 &#39;HELLO&#39;\nconsole.log(&#39;Hey&#39;.startsWith(&#39;H&#39;)); &#x2F;&#x2F; 输出 true\n\n在 JavaScript 文档中可以查看更多的字符串内建方法。\nBuilt-in Objects（内建对象）除 console 外，Javascript 还包含其他内建对象。例如，对于复杂数学运算，可使用内建的 Math 对象，可调用其 .random() 方法，用来输出0-1中的一个随机数：\nconsole.log(Math.random()); &#x2F;&#x2F; 输出0-1中的一个随机数\n\n若想获取0-50中的一个随机数，可以将 Math.random() 的结果乘以50：\nMath.random() * 50;\n\n上例中，其结果可能不是整数。可以使用 Math.floor() 方法返回一个临近该结果的整数。\nMath 对象的其他方法可参考此处。\n","slug":"JavaScript-动手学-1","date":"2019-10-08T07:44:10.000Z","categories_index":"动手学,Javascript","tags_index":"动手学,Javascript","author_index":"Ryanhui"},{"id":"8999d7cf837e7c1b6f9d05e36d4f5aae","title":"Debian 9 远程服务器搭建和应用踩坑实录","content":"\n\n\n\n\n\n\n\n\n麻麻再也不用担心我用科学上网啦 =￣ω￣=\n本实录均基于 Vultr 日本节点 CentOS 7.5 x64 服务器搭建运行实际效果总结得出，可能无法代表不同地区不同系统的服务器节点的运行效果。\n\n连接服务器：Xshell，Putty可以在官网上注册获取 Xshell 的免费版本，也可以使用 Putty 作为代替。\n登录使用 Xshell 第一次连接服务器时需要输入 VPS 运营商给出的用户密码，可以保存登录凭证，重新连接服务器时无需再次输入密码。Putty 每次登陆时都需要输入密码。\n使用 Putty 时，长时间没有更新的会话会自动断联，可以通过在 Connection 选项卡中设置定时向服务器发送空数据包，避免长时间不用反复重连。\n\n注销结束操作后一定要注销会话，避免服务器账户还在登录的状态，占用服务器资源。\n在 Xshell 或者 Putty 中均可按快捷键 ctrl+d 快速结束访问。\n内网穿透：FrpFrp 是一个高性能的反向代理应用，可以帮助您轻松地进行内网穿透，对外网提供服务，支持 tcp, http, https 等协议类型，并且 web 服务支持根据域名进行路由转发。\n服务端部署：Frps一键配置脚本\n配置说明：\nPlease input frps bind_port [1-65535](Default Server Port: 5443): #输入frp提供服务的端口，用于服务器端和客户端通信，默认即可\nPlease input frps vhost_http_port [1-65535](Default vhost_http_port: 80): #输入frp进行http穿透的http服务端口，建议不用默认\nPlease input frps vhost_https_port [1-65535](Default vhost_https_port: 443): #输入frp进行https穿透的https服务端口，建议不用默认\nPlease input frps dashboard_port [1-65535](Default dashboard_port: 6443):#输入frp的控制台服务端口，用于查看frp工作状态，默认即可\nPlease input dashboard_user (Default: admin):#登录控制台的用户名，默认即可\nPlease input dashboard_pwd (Default: kpkpM7VZ):#登录控制台的密码，如果记不住默认的建议修改\nPlease input privilege_token (Default: 9m2UAOWa6hx5Eise):#输入frp服务器和客户端通信的密码，默认是随机生成的，默认即可\nPlease input frps max_pool_count [1-200](Default max_pool_count: 50):#设置每个代理可以创建的连接池上限，默认50\n&#x3D;&#x3D;&#x3D;&#x3D; Please select log_level &#x3D;&#x3D;&#x3D;&#x3D;\n1: info\n2: warn\n3: error\n4: debug\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nEnter your choice (1, 2, 3, 4 or exit. default [1]): #默认即可\nPlease input frps log_max_days [1-30](Default log_max_days: 3 day):\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Please select log_file &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n1: enable\n2: disable\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nEnter your choice (1, 2 or exit. default [1]):#默认即可\n\nCentOS 下需要运行以下指令打开服务器防火墙端口 6443（Debian 默认开放防火墙，如果无法访问端口请查看服务器运行商网站控制台，编辑安全组策略）：\n# 开启6443端口\nfirewall-cmd --zone&#x3D;public --add-port&#x3D;6443&#x2F;tcp --permanent\nfirewall-cmd --reload # 重启防火墙\nfirewall-cmd --list-ports # 查看已开放端口\n# 如果需要测试，可以尝试以下命令\nsystemctl stop firewalld.service # 停止防火墙\nsystemctl disable firewalld.service # 禁止防火墙开机启动\n# 关闭已开放的端口\nfirewall-cmd --zone&#x3D;public --remove-port&#x3D;80&#x2F;tcp --permanent\n\n在浏览器中打开 服务器ip:6443，输入控制台用户名和密码。如果可以进入控制台面板，表示 frps 部署成功，可以使用了。\n客户端部署：Frpc在需要穿透的内网机器（Windows 远程桌面为例）上下载对应操作系统和版本的 Frp，在 frpc.ini 中配置：\n[common]\nserver_addr &#x3D; 0.0.0.0 # 服务器地址\nserver_port &#x3D; 5443 # frp 提供服务的端口\nprotocol &#x3D; tcp # 连接协议，可选 tcp&#x2F;kcp\ntoken &#x3D; 12345678 # 认证用\n\n[RDP] # 代理名称，可随意设置\ntype &#x3D; tcp # 协议，可选 tcp&#x2F;udp\nlocal_ip &#x3D; 127.0.0.1\nlocal_port &#x3D; 3389 # Windows 远程桌面端口\n# if remote_port is 0, frps will assign a random port for you\nremote_port &#x3D; 6000\n\n在 cmd 中 cd 到 frpc 文件目录下，执行 frpc -c frpc.ini（Powershell 中执行 ./frpc -c ./frpc.ini），并确认服务器端 6000 端口已开放。此时在另一台电脑下打开 Remote Desktop，输入 服务器ip:6000，即可访问远程桌面。\n科学上网：v2rayLinux 安装脚本V2Ray 提供了一个在 Linux 中的自动化安装脚本。这个脚本会自动检测有没有安装过 V2Ray，如果没有，则进行完整的安装和配置；如果之前安装过 V2Ray，则只更新 V2Ray 二进制程序而不更新配置。\n以下指令假设已在 su 环境下，如果不是，请先运行 sudo su。\n运行下面的指令下载并安装 V2Ray。当 yum 或 apt-get 可用的情况下，此脚本会自动安装 unzip 和 daemon。这两个组件是安装 V2Ray 的必要组件。如果你使用的系统不支持 yum 或 apt-get，请自行安装 unzip 和 daemon。\nbash &lt;(curl -L -s https:&#x2F;&#x2F;install.direct&#x2F;go.sh)\n\n此脚本会配置自动运行脚本。自动运行脚本会在系统重启之后，自动运行 V2Ray。脚本运行完成后，你需要：\n\n编辑 /etc/v2ray/config.json 文件来配置你需要的代理方式；\n运行 service v2ray start 来启动 V2Ray 进程；\n之后可以使用 service v2ray start|stop|status|reload|restart|force-reload 控制 V2Ray 的运行。\n\n","slug":"CentOS-7-远程服务器搭建和应用踩坑实录","date":"2019-08-04T02:45:21.000Z","categories_index":"技术","tags_index":"Linux,MariaSQL,网络技术,科学使用","author_index":"Ryanhui"},{"id":"9cf1570f7db7f75fb8362c869acb770d","title":"Anaconda 虚拟环境配置和使用","content":"转自：cnblog，CSDN\n\nConda 环境管理创建环境使用 conda create 命令，后边跟上你希望用来称呼它的任何名字：\nconda create --name snowflakes biopython\n\n这条命令将会在 Anaconda3/envs/snowflakes 创建一个新的环境，并预先安装第三方扩展库 biopython。\n小技巧：很多跟在 -- 后边常用的命令选项，可以被略写为一个短线加命令首字母。所以 --name 选项和 -n 的作用是一样的。通过 conda -h 或 conda –-help 来看大量的缩写。\n激活环境在 Linux，OS X 上：\nsource activate snowflakes\n\n在 Windows 上：\nactivate snowflakes\n\n创建第二个环境这次让我们来创建并命名一个新环境，然后安装另一个版本的 Python 以及两个包 Astroid 和 Babel。\nconda create -n bunnies python&#x3D;3 Astroid Babel\n\n这将创建第二个基于 Python3 ，包含 Astroid 和 Babel 包，称为 bunnies 的新环境，在 /envs/bunnies 文件夹里。\n列出所有的环境conda info --envs\n\n切换到另一个环境（activate/deactivate）为了切换到另一个环境，键入下列命令以及所需环境的名字。\n在 Linux，OS X 上：\nsource activate snowflakes\n\n在 Windows 上：\nactivate snowflakes\n\n如果要从你当前工作环境的路径切换到默认环境时，键入：\n在 Linux，OS X 上：\nsource deactivate\n\n在 Windows 上：\ndeactivate\n\n复制环境通过克隆来复制一个环境。通过克隆snowfllakes来创建一个称为flowers的副本。\nconda create -n flowers --clone snowflakes\n\n通过 conda info –-envs 来检查环境你现在应该可以看到一个环境列表：flowers, bunnies, and snowflakes。\n删除环境如果你不想要这个名为 flowers 的环境，就按照如下方法移除该环境：\nconda remove -n flowers --all\n\n包管理安装包conda install package\n\n移除包conda remove -n env package\n\n更新包：\nconda update -n env package\n\nconda：\nconda update conda\n\nAnaconda：\nconda update anaconda\n\nPython：\nconda update python\n\njupyter notebook更改默认工作路径在 Anaconda Prompt 终端中输入下面命令，生成 notebook 配置文件：\njupyter notebook --generate-config\n\n根据你运行实际显示的路径，打开这个配置文件。\n找到 c.NotebookApp.notebook_dir 并修改然后保存，后面的是自己要设置的目录。\n\n设置好之后，在开始菜单打开 Jupyter Notebook 可能还是显示的原来的工作路径。修改方案是：\n先找到快捷方式的保存目录，\n\n鼠标右击属性 把 % *** % 删除掉，% 里面的东西是默认工作路径指定用户的工作路径，不删除无论你怎么设置都不会起作用的。 \n\n添加 conda 虚拟环境(base)$ conda create -n cenv\n(cenv)$ conda install ipykernel\n(cenv)$ ipython kernel install --user --name&#x3D;&lt;any_name_for_kernel&gt;\n(cenv)$ conda deactivate\n\n重启 notebook。\n删除 conda 虚拟环境查看已经添加的环境。\njupyter kernelspec list\n\n删除不用的环境。\njupyter kernelspec uninstall unwanted-kernel\n\n重启 notebook。\n","slug":"Anaconda-虚拟环境配置和使用","date":"2019-07-25T08:58:03.000Z","categories_index":"Python","tags_index":"Anaconda,Python","author_index":"Ryanhui"},{"id":"6b8807c9c6e36a32de17577c2c2f0dfa","title":"Python 内建数据结构，函数和文件系统","content":"Python 内建数据结构，函数和文件系统学习笔记。\n\nData Structures and Sequences（数据结构和序列）Tuple（元组）用逗号分隔创建元组。\ntup &#x3D; 4, 5, 6\ntup\n\n\n\n\n(4, 5, 6)\n\n创建嵌套元组。\nnested_tup &#x3D; (4, 5, 6), (7, 8)\nnested_tup\n\n\n\n\n((4, 5, 6), (7, 8))\n\n使用 tuple 将任意序列或迭代器转换为元组。\ntuple([4, 0, 2])\ntup &#x3D; tuple(&#39;string&#39;)\ntup\n\n\n\n\n(&#39;s&#39;, &#39;t&#39;, &#39;r&#39;, &#39;i&#39;, &#39;n&#39;, &#39;g&#39;)\n\n获取元组中的元素。\ntup[0]\n\n\n\n\n&#39;s&#39;\n\n元组中储存的对象自身是可变的，但元组一旦被创建，各位置上的对象无法被修改。\ntup &#x3D; tuple([&#39;foo&#39;, [1, 2], True])\ntup[2] &#x3D; False\n\n\n---------------------------------------------------------------------------\n\nTypeError                                 Traceback (most recent call last)\n\n&lt;ipython-input-13-11b694945ab9&gt; in &lt;module&gt;\n      1 tup = tuple([&#39;foo&#39;, [1, 2], True])\n----&gt; 2 tup[2] = False\n\n\nTypeError: &#39;tuple&#39; object does not support item assignment\n\n如果元组中的对象是可变的，则可以在它内部进行修改。\ntup[1].append(3)\ntup\n\n\n\n\n(&#39;foo&#39;, [1, 2, 3], True)\n\n+ 链接元组。\n(4, None, &#39;foo&#39;) + (6, 0) + (&#39;bar&#39;,)\n\n\n\n\n(4, None, &#39;foo&#39;, 6, 0, &#39;bar&#39;)\n\n* 生成多个元组的拷贝。\n(&#39;foo&#39;, &#39;bar&#39;) * 4\n\n\n\n\n(&#39;foo&#39;, &#39;bar&#39;, &#39;foo&#39;, &#39;bar&#39;, &#39;foo&#39;, &#39;bar&#39;, &#39;foo&#39;, &#39;bar&#39;)\n\n注意此时对象没有改变，只是指向他们的引用进行了复制。\nUnpacking tuples（元组拆包）tup &#x3D; (4, 5, 6)\na, b, c &#x3D; tup\nb\n\n\n\n\n5\n\n嵌套元组拆包。\ntup &#x3D; 4, 5, (6, 7)\na, b, (c, d) &#x3D; tup\nd\n\n\n\n\n7\n\n使用此方法交换对象的变量名。\na, b &#x3D; 1, 2\nprint(a, b)\n\nb, a &#x3D; a, b\nprint(a, b)\n\n1 2\n2 1\n\n拆包遍历元组或列表。\nseq &#x3D; [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\nfor a, b, c in seq:\n    print(&#39;a&#x3D;&#123;0&#125;, b&#x3D;&#123;1&#125;, c&#x3D;&#123;2&#125;&#39;.format(a, b, c))\n\na=1, b=2, c=3\na=4, b=5, c=6\na=7, b=8, c=9\n\n使用 *[变量名] 获取从元组的某一位置开始任意长度的参数列表。\nvalues &#x3D; 1, 2, 3, 4, 5\na, b, *rest &#x3D; values\na, b\nrest\n\n\n\n\n[3, 4, 5]\n\n此方法可以用于剔除不想要的数据，为表示方便，使用 _ 做变量名代表不想要的变量。\na, b, *_ &#x3D; values\n\nTuple methods（元组方法）count 方法统计元组中某个对象出现的次数。\na &#x3D; (1, 2, 2, 2, 3, 4, 2)\na.count(2)\n\n\n\n\n4\n\nList（列表）使用 [] 或者 list 类型函数定义列表。\na_list &#x3D; [2, 3, 7, None]\ntup &#x3D; (&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;)\nb_list &#x3D; list(tup)\nb_list\nb_list[1] &#x3D; &#39;peekaboo&#39;\nb_list\n\n\n\n\n[&#39;foo&#39;, &#39;peekaboo&#39;, &#39;baz&#39;]\n\n使用 list 将迭代器或者生成器转化为列表。\ngen &#x3D; range(10)\ngen\n\n\n\n\nrange(0, 10)\n\nlist(gen)\n\n\n\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nAdding and removing elements（增加与移除元素）append 方法将元素添加到列表尾部。\nb_list.append(&#39;dwarf&#39;)\nb_list\n\n\n\n\n[&#39;foo&#39;, &#39;peekaboo&#39;, &#39;baz&#39;, &#39;dwarf&#39;]\n\ninsert 方法将元素插入列表指定位置。\nb_list.insert(1, &#39;red&#39;)\nb_list\n\n\n\n\n[&#39;foo&#39;, &#39;red&#39;, &#39;peekaboo&#39;, &#39;baz&#39;, &#39;dwarf&#39;]\n\npop 方法将特定位置的元素移除并返回。\nb_list.pop(2)\nb_list\n\n\n\n\n[&#39;foo&#39;, &#39;red&#39;, &#39;baz&#39;, &#39;dwarf&#39;]\n\nremove 方法将定位第一个符合要求的值并移除它。\nb_list.append(&#39;foo&#39;)\nprint(b_list)\nb_list.remove(&#39;foo&#39;)\nb_list\n\n[&#39;foo&#39;, &#39;red&#39;, &#39;baz&#39;, &#39;dwarf&#39;, &#39;foo&#39;]\n\n\n\n\n\n[&#39;red&#39;, &#39;baz&#39;, &#39;dwarf&#39;, &#39;foo&#39;]\n\nin 关键字检查元素是否在列表中。\n&#39;dwarf&#39; in b_list\n\n\n\n\nTrue\n\nnot 用作 in 的反义词，表示“不在”。\n&#39;dwarf&#39; not in b_list\n\n\n\n\nFalse\n\nConcatenating and combining lists（连接和联合列表）用 + 连接列表。\n[4, None, &#39;foo&#39;] + [7, 8, (2, 3)]\n\n\n\n\n[4, None, &#39;foo&#39;, 7, 8, (2, 3)]\n\n用 extend 向列表尾部添加多个元素。\nx &#x3D; [4, None, &#39;foo&#39;]\nx.extend([7, 8, (2, 3)])\nx\n\n\n\n\n[4, None, &#39;foo&#39;, 7, 8, (2, 3)]\n\n当需要构建大列表时，用 extend 相比 + 代价更小，效率更高。\neverything &#x3D; []\nfor chunk in list_of_lists:\n    everything.extend(chunk)\n\nSorting（排序）sort 方法对列表内部排序（不新建对象）\na &#x3D; [7, 2, 5, 1, 3]\na.sort()\na\n\n\n\n\n[1, 2, 3, 5, 7]\n\n传递对应的关键字实现不同的方法，例如根据字符串的长度排序。\nb &#x3D; [&#39;saw&#39;, &#39;small&#39;, &#39;He&#39;, &#39;foxes&#39;, &#39;six&#39;]\nb.sort(key&#x3D;len)\nb\n\n\n\n\n[&#39;He&#39;, &#39;saw&#39;, &#39;six&#39;, &#39;small&#39;, &#39;foxes&#39;]\n\nBinary search and maintaining a sorted list（二分搜索与已排序列表的维护）内建 bisect 模块实现了二分搜索和已排序列表的插值。bisect.bisect 会找到元素应当插入的位置，bisect.insort 将元素插入到相应位置。\nimport bisect\nc &#x3D; [1, 2, 2, 2, 3, 4, 7]\nbisect.bisect(c, 2)\n\n\n\n\n4\n\nbisect.bisect(c, 5)\n\n\n\n\n6\n\nbisect.insort(c, 6)\nc\n\n\n\n\n[1, 2, 2, 2, 3, 4, 6, 7]\n\nSlicing（切片）切片符号 [起始位置:结束位置]。\nseq &#x3D; [7, 2, 3, 7, 5, 6, 0, 1]\nseq[1:5]\n\n\n\n\n[2, 3, 7, 5]\n\n切片还可将序列赋给变量。\nseq[3:4] &#x3D; [6, 3]\nseq\n\n\n\n\n[7, 2, 3, 6, 3, 5, 6, 0, 1]\n\n起始位置的元素是包含的，结束位置的元素不包含，因此切片元素的数量是 结束位置-起始位置。\nseq[:5]\nseq[3:]\n\n从序列尾部索引。\nseq[-4:]\n\n\n\n\n[5, 6, 0, 1]\n\nseq[-6:-2]\n\n\n\n\n[6, 3, 5, 6]\n\n设置步进值。\nseq[::2]\n\n\n\n\n[7, 3, 3, 6, 1]\n\n翻转列表。\nseq[::-1]\n\n\n\n\n[1, 0, 6, 5, 3, 6, 3, 2, 7]\n\nBuilt-in Sequence Functions（内建序列函数）enumerate遍历一个序列时需要追踪当前对象的索引。\ni &#x3D; 0\nfor value in collection:\n   # do something with value\n   i +&#x3D; 1\n\n内建 enumerate 函数可以返回 (i, value) 元组，其中 value 是元素值，i 是元素的索引。\nfor i, value in enumerate(collection):\n   # do something with value\n\n当需要对数据建立索引时，可以使用 enumerate 构造一个字典，将列表元素值（如果是唯一的）映射到字典索引位置上。\nsome_list &#x3D; [&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;]\nmapping &#x3D; &#123;&#125;\nfor i, v in enumerate(some_list):\n    mapping[v] &#x3D; i\nmapping\n\n\n\n\n&#123;&#39;foo&#39;: 0, &#39;bar&#39;: 1, &#39;baz&#39;: 2&#125;\n\nsorted返回一个根据任意序列中元素新建的已排序列表。接受的参数与列表的 sort 方法一致。\nsorted([7, 1, 2, 6, 0, 3, 2])\n\n\n\n\n[0, 1, 2, 2, 3, 6, 7]\n\nsorted(&#39;horse race&#39;)\n\n\n\n\n[&#39; &#39;, &#39;a&#39;, &#39;c&#39;, &#39;e&#39;, &#39;e&#39;, &#39;h&#39;, &#39;o&#39;, &#39;r&#39;, &#39;r&#39;, &#39;s&#39;]\n\nzip将列表、元组或其他序列的元素配对，新建一个元组构建的列表\nseq1 &#x3D; [&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;]\nseq2 &#x3D; [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;]\nzipped &#x3D; zip(seq1, seq2)\nlist(zipped)\n\n\n\n\n[(&#39;foo&#39;, &#39;one&#39;), (&#39;bar&#39;, &#39;two&#39;), (&#39;baz&#39;, &#39;three&#39;)]\n\n可以接受不同长度的序列，列表长度由最短的序列决定。\nseq3 &#x3D; [False, True]\nlist(zip(seq1, seq2, seq3))\n\n\n\n\n[(&#39;foo&#39;, &#39;one&#39;, False), (&#39;bar&#39;, &#39;two&#39;, True)]\n\n与 enumerate 合用同时遍历多个序列。\nfor i, (a, b) in enumerate(zip(seq1, seq2)):\n    print(&#39;&#123;0&#125;: &#123;1&#125;, &#123;2&#125;&#39;.format(i, a, b))\n\n0: foo, one\n1: bar, two\n2: baz, three\n\n拆分一个已配对的序列。\npitchers &#x3D; [(&#39;Nolan&#39;, &#39;Ryan&#39;), (&#39;Roger&#39;, &#39;Clemens&#39;),\n            (&#39;Schilling&#39;, &#39;Curt&#39;)]\nfirst_names, last_names &#x3D; zip(*pitchers)\nprint(first_names, &quot;\\n&quot;, last_names)\n\n(&#39;Nolan&#39;, &#39;Roger&#39;, &#39;Schilling&#39;) \n (&#39;Ryan&#39;, &#39;Clemens&#39;, &#39;Curt&#39;)\n\nreversed将列表倒序排列。\nlist(reversed(range(10)))\n\n\n\n\n[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n\ndict（字典）又称哈希表或关联数组，是尺寸灵活的键值对集合。用 &#123;&#125; 创建。\nempty_dict &#x3D; &#123;&#125;\nd1 &#x3D; &#123;&#39;a&#39; : &#39;some value&#39;, &#39;b&#39; : [1, 2, 3, 4]&#125;\nd1\n\n\n\n\n&#123;&#39;a&#39;: &#39;some value&#39;, &#39;b&#39;: [1, 2, 3, 4]&#125;\n\n访问、插入和设置字典中元素。\nd1[7] &#x3D; &#39;an integer&#39;\nd1\n\n\n\n\n&#123;&#39;a&#39;: &#39;some value&#39;, &#39;b&#39;: [1, 2, 3, 4], 7: &#39;an integer&#39;&#125;\n\nd1[&#39;b&#39;]\n\n\n\n\n[1, 2, 3, 4]\n\n检查字典中是否有一个键。\n&#39;b&#39; in d1\n\n\n\n\nTrue\n\n用 del 和 pop 方法删除值，pop 方法在删除的同时返回被删的值，并删除键。\nd1[5] &#x3D; &#39;some value&#39;\nprint(d1)\n\nd1[&#39;dummy&#39;] &#x3D; &#39;another value&#39;\nprint(d1)\n\ndel d1[5]\nprint(d1)\n\nret &#x3D; d1.pop(&#39;dummy&#39;)\nprint(ret)\nprint(d1)\n\n&#123;&#39;a&#39;: &#39;some value&#39;, &#39;b&#39;: [1, 2, 3, 4], 7: &#39;an integer&#39;, 5: &#39;some value&#39;&#125;\n&#123;&#39;a&#39;: &#39;some value&#39;, &#39;b&#39;: [1, 2, 3, 4], 7: &#39;an integer&#39;, 5: &#39;some value&#39;, &#39;dummy&#39;: &#39;another value&#39;&#125;\n&#123;&#39;a&#39;: &#39;some value&#39;, &#39;b&#39;: [1, 2, 3, 4], 7: &#39;an integer&#39;, &#39;dummy&#39;: &#39;another value&#39;&#125;\nanother value\n&#123;&#39;a&#39;: &#39;some value&#39;, &#39;b&#39;: [1, 2, 3, 4], 7: &#39;an integer&#39;&#125;\n\nkeys 和 values 分别返回字典键、值的迭代器，顺序与字典的顺序对应。\nlist(d1.keys())\n\n\n\n\n[&#39;a&#39;, &#39;b&#39;, 7]\n\nlist(d1.values())\n\n\n\n\n[&#39;some value&#39;, [1, 2, 3, 4], &#39;an integer&#39;]\n\nupdate 方法将两个字典合并。\nd1.update(&#123;&#39;b&#39; : &#39;foo&#39;, &#39;c&#39; : 12&#125;)\nd1\n\n\n\n\n&#123;&#39;a&#39;: &#39;some value&#39;, &#39;b&#39;: &#39;foo&#39;, 7: &#39;an integer&#39;, &#39;c&#39;: 12&#125;\n\n如果传给 update 方法的数据中包含与字典相同的键，则其键值将被覆盖。\nCreating dicts from sequences（从序列生成字典）构建包含两个序列的字典，键值按元素配对。\nmapping &#x3D; &#123;&#125;\nfor key, value in zip(key_list, value_list):\n    mapping[key] &#x3D; value\n\n也可通过接受一个2-元组（含有两个元素的元组）的列表构建。\nmapping &#x3D; dict(zip(range(5), reversed(range(5))))\nmapping\n\n\n\n\n&#123;0: 4, 1: 3, 2: 2, 3: 1, 4: 0&#125;\n\nDefault values（默认值）设置字典默认值的算法。\nif key in some_dict:\n    value &#x3D; some_dict[key]\nelse:\n    value &#x3D; default_value\n\n字典的 get 和 pop 方法可以返回一个默认值。\nvalue &#x3D; some_dict.get(key, default_value)\n\n带默认值的 get 方法在 key 参数不是字典键时返回 None，而 pop 会抛出异常。\nwords &#x3D; [&#39;apple&#39;, &#39;bat&#39;, &#39;bar&#39;, &#39;atom&#39;, &#39;book&#39;]\nby_letter &#x3D; &#123;&#125;\nfor word in words:\n    letter &#x3D; word[0]\n    if letter not in by_letter:\n        by_letter[letter] &#x3D; [word]\n    else:\n        by_letter[letter].append(word)\nby_letter\n\n\n\n\n&#123;&#39;a&#39;: [&#39;apple&#39;, &#39;atom&#39;], &#39;b&#39;: [&#39;bat&#39;, &#39;bar&#39;, &#39;book&#39;]&#125;\n\n上述分类算法可简写为：\nby_letter &#x3D; &#123;&#125;\nfor word in words:\n    letter &#x3D; word[0]\n    by_letter.setdefault(letter, []).append(word)\nby_letter\n\n\n\n\n&#123;&#39;a&#39;: [&#39;apple&#39;, &#39;atom&#39;], &#39;b&#39;: [&#39;bat&#39;, &#39;bar&#39;, &#39;book&#39;]&#125;\n\n也可使用内建的集合模块中的类 defaultdict，进一步简化算法。\nfrom collections import defaultdict\nby_letter &#x3D; defaultdict(list)\nfor word in words:\n    by_letter[word[0]].append(word)\nby_letter\n\n\n\n\ndefaultdict(list, &#123;&#39;a&#39;: [&#39;apple&#39;, &#39;atom&#39;], &#39;b&#39;: [&#39;bat&#39;, &#39;bar&#39;, &#39;book&#39;]&#125;)\n\nValid dict key types（有效字典键类型）键必须为不可变对象。可以通过 hash 函数检查一个对象是否可以哈希化（是否可用作字典的键）。 \nhash(&#39;string&#39;)\n\n\n\n\n8227767748255084375\n\nhash((1, 2, (2, 3)))\n\n\n\n\n1097636502276347782\n\nhash((1, 2, [2, 3])) # fails because lists are mutable\n\n\n---------------------------------------------------------------------------\n\nTypeError                                 Traceback (most recent call last)\n\n&lt;ipython-input-26-473c35a62c0b&gt; in &lt;module&gt;\n----&gt; 1 hash((1, 2, [2, 3])) # fails because lists are mutable\n\n\nTypeError: unhashable type: &#39;list&#39;\n\n为使列表作键，可将其转换为元组。\nd &#x3D; &#123;&#125;\nd[tuple([1, 2, 3])] &#x3D; 5\nd\n\n\n\n\n&#123;(1, 2, 3): 5&#125;\n\nset（集合）集合只有键没有值（因此集合中相同的元素会被合并），通过 set 函数或 &#123;&#125; 创建。\nset([2, 2, 2, 1, 3, 3])\n\n\n\n\n&#123;1, 2, 3&#125;\n\n&#123;2, 2, 2, 1, 3, 3&#125;\n\n\n\n\n&#123;1, 2, 3&#125;\n\n支持数学上的集合操作，如交、并、补和差集。\na &#x3D; &#123;1, 2, 3, 4, 5&#125;\nb &#x3D; &#123;3, 4, 5, 6, 7, 8&#125;\n\n并集。（使用 union 或 | 创建）\nprint(a.union(b))\nprint(a | b)\n\n&#123;1, 2, 3, 4, 5, 6, 7, 8&#125;\n&#123;1, 2, 3, 4, 5, 6, 7, 8&#125;\n\n交集。（使用 intersection 或 &amp; 创建）\nprint(a.intersection(b), a &amp; b)\n\n&#123;3, 4, 5&#125; &#123;3, 4, 5&#125;\n\n对于大型集合，下面的代码效率更高。\nc &#x3D; a.copy()\nc |&#x3D; b\nprint(c)\nd &#x3D; a.copy()\nd &amp;&#x3D; b\nprint(d)\n\n&#123;1, 2, 3, 4, 5, 6, 7, 8&#125;\n&#123;3, 4, 5&#125;\n\n集合的元素必须是不可变的。\nmy_data &#x3D; [1, 2, 3, 4]\nmy_set &#x3D; &#123;tuple(my_data)&#125;\nmy_set\n\n\n\n\n&#123;(1, 2, 3, 4)&#125;\n\n检查一个集合是否是另一个集合的子集（包含于）或超集（被包含）。\na_set &#x3D; &#123;1, 2, 3, 4, 5&#125;\n&#123;1, 2, 3&#125;.issubset(a_set)\n\n\n\n\nTrue\n\na_set.issuperset(&#123;1, 2, 3&#125;)\n\n\n\n\nTrue\n\n仅当两个集合内容一模一样时两个集合才相等。\n&#123;1, 2, 3&#125; &#x3D;&#x3D; &#123;3, 2, 1&#125;\n\n\n\n\nTrue\n\nList, Set, and Dict Comprehensions（列表、集合和字典的推导式）列表推导式的基本形式：\n[expr for val in collection if condition]\n\n其可等同于如下语句：\nresult &#x3D; []\nfor val in collection:\n    if condition\n        result.append(expr)\n\n过滤条件可以忽略。下面字符串中长度大于2的字符串改为大写。\nstrings &#x3D; [&#39;a&#39;, &#39;as&#39;, &#39;bat&#39;, &#39;car&#39;, &#39;dove&#39;, &#39;python&#39;]\n[x.upper() for x in strings if len(x) &gt; 2]\n\n\n\n\n[&#39;BAT&#39;, &#39;CAR&#39;, &#39;DOVE&#39;, &#39;PYTHON&#39;]\n\n字典推导式：\ndict_comp &#x3D; &#123;key-expr: value-expr for value in collection if condition&#125;\n\n集合推导式：\nset_comp &#x3D; &#123;expr for value in collection if condition&#125;\n\n创建一个包含列表中字符串长度的集合。\nunique_lengths &#x3D; &#123;len(x) for x in strings&#125;\nunique_lengths\n\n\n\n\n&#123;1, 2, 3, 4, 6&#125;\n\n使用 map 函数可以更简洁实现这一功能。\nset(map(len, strings))\n\n\n\n\n&#123;1, 2, 3, 4, 6&#125;\n\n创建一个将字符串与其位置相匹配的字典。\nloc_mapping &#x3D; &#123;val : index for index, val in enumerate(strings)&#125;\nloc_mapping\n\n\n\n\n&#123;&#39;a&#39;: 0, &#39;as&#39;: 1, &#39;bat&#39;: 2, &#39;car&#39;: 3, &#39;dove&#39;: 4, &#39;python&#39;: 5&#125;\n\nNested list comprehensions（嵌套列表推导式）all_data &#x3D; [[&#39;John&#39;, &#39;Emily&#39;, &#39;Michael&#39;, &#39;Mary&#39;, &#39;Steven&#39;],\n            [&#39;Maria&#39;, &#39;Juan&#39;, &#39;Javier&#39;, &#39;Natalia&#39;, &#39;Pilar&#39;]]\n\n通过 for 循环获得上述列表中包含2个以上 e 字母的名字。\nnames_of_interest &#x3D; []\nfor names in all_data:\n    enough_es &#x3D; [name for name in names if name.count(&#39;e&#39;) &gt;&#x3D; 2]\n    names_of_interest.extend(enough_es)\n\n通过嵌套列表推导式表达上述语句：\nresult &#x3D; [name for names in all_data for name in names\n          if name.count(&#39;e&#39;) &gt;&#x3D; 2]\nresult\n\n\n\n\n[&#39;Steven&#39;]\n\n其中 for 循环部分是根据嵌套的顺序排列的。\n将含有整数元组的列表扁平3为一个简单的整数列表。\nsome_tuples &#x3D; [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\nflattened &#x3D; [x for tup in some_tuples for x in tup]\nflattened\n\n\n\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nfor 表达式的顺序应与写嵌套 for 语句时的顺序一致。\nflattened &#x3D; []\n\nfor tup in some_tuples:\n    for x in tup:\n        flattened.append(x)\nflattened\n\n\n\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n嵌套推导式要和列表推导式中的列表推导式区分：\n[[x for x in tup] for tup in some_tuples]\n\n\n\n\n[[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nFunctions（函数）函数声明使用 def 关键字，返回使用 return 关键字。\ndef my_function(x, y, z&#x3D;1.5):\n    if z &gt; 1:\n        return z * (x + y)\n    else:\n        return z &#x2F; (x + y)\n\n上述函数中 x y 是位置参数，z 是关键字参数。\n其调用方式为\nmy_function(5, 6, z&#x3D;0.7)\nmy_function(3.14, 7, 3.5)\nmy_function(10, 20)\n\nNamespaces, Scope, and Local Functions（命名空间、作用域和本地函数）在函数内部，任意变量都是默认分配到本地命名空间。函数执行后，本地命名空间就会被销毁。下例中，a 在函数退出后被销毁。\ndef func():\n    a &#x3D; []\n    for i in range(5):\n        a.append(i)\n\n可以像下面这样声明 a：\na &#x3D; []\ndef func():\n    for i in range(5):\n        a.append(i)\nfunc()\na\n\n\n\n\n[0, 1, 2, 3, 4]\n\n用 global 关键字声明变量为全局变量。\na &#x3D; None\ndef bind_a_variable():\n    global a\n    a &#x3D; []\nbind_a_variable()\nprint(a)\n\n[]\n\nReturning Multiple Values（返回多个值）从函数中返回多个值。\ndef f():\n    a &#x3D; 5\n    b &#x3D; 6\n    c &#x3D; 7\n    return a, b, c\n\na, b, c &#x3D; f()\n\n用一下代码进行代替，返回的 return_value 是一个3-元组\nreturn_value &#x3D; f()\n\n也可以这样实现。\ndef f():\n    a &#x3D; 5\n    b &#x3D; 6\n    c &#x3D; 7\n    return &#123;&#39;a&#39; : a, &#39;b&#39; : b, &#39;c&#39; : c&#125;\n\nFunctions Are Objects（函数是对象）states &#x3D; [&#39;   Alabama &#39;, &#39;Georgia!&#39;, &#39;Georgia&#39;, &#39;georgia&#39;, &#39;FlOrIda&#39;,\n          &#39;south   carolina##&#39;, &#39;West virginia?&#39;]\n\n定义函数clean_strings 整理上述字符串（调用正则化模块 re）。\nimport re\n\ndef clean_strings(strings):\n    result &#x3D; []\n    for value in strings:\n        value &#x3D; value.strip()                 # 去除前后空格\n        value &#x3D; re.sub(&#39;[!#?]&#39;, &#39;&#39;, value)    # 移除标点符号\n        value &#x3D; value.title()                 # 调整大小写\n        result.append(value)\n    return result\n\n\nclean_strings(states)\n\n\n\n\n[&#39;Alabama&#39;,\n &#39;Georgia&#39;,\n &#39;Georgia&#39;,\n &#39;Georgia&#39;,\n &#39;Florida&#39;,\n &#39;South   Carolina&#39;,\n &#39;West Virginia&#39;]\n\n因为函数是对象，也可以以列表形式将函数以参数的方式传递给其他函数。\ndef remove_punctuation(value):\n    return re.sub(&#39;[!#?]&#39;, &#39;&#39;, value)\n\nclean_ops &#x3D; [str.strip, remove_punctuation, str.title]\n\ndef clean_strings(strings, ops):\n    result &#x3D; []\n    for value in strings:\n        for function in ops:\n            value &#x3D; function(value)\n        result.append(value)\n    return result\n\n\nclean_strings(states, clean_ops)\n\n\n\n\n[&#39;Alabama&#39;,\n &#39;Georgia&#39;,\n &#39;Georgia&#39;,\n &#39;Georgia&#39;,\n &#39;Florida&#39;,\n &#39;South   Carolina&#39;,\n &#39;West Virginia&#39;]\n\n内建 map 函数也可将一个函数应用到一个序列上。\nfor x in map(remove_punctuation, states):\n    print(x)\n\n   Alabama \nGeorgia\nGeorgia\ngeorgia\nFlOrIda\nsouth   carolina\nWest virginia\n\nAnonymous (Lambda) Functions（匿名函数）匿名函数（也称 lambda 函数）是指通过单个语句定义函数的方式，其结果为返回值。匿名函数通过使用 lambda 关键字定义。\ndef short_function(x):\n    return x * 2\n\nequiv_anon &#x3D; lambda x: x * 2\nequiv_anon(2)\n\n\n\n\n4\n\n匿名函数代码量小，也可作为参数进行传值。\ndef apply_to_list(some_list, f):\n    return [f(x) for x in some_list]\n\nints &#x3D; [4, 0, 1, 5, 6]\napply_to_list(ints, lambda x: x * 2)\n\n\n\n\n[8, 0, 2, 10, 12]\n\n将下例字符串按不同字母的数量排序，可以将一个匿名函数（即将每个列表中的每个元素转换成集合，并根据转换后集合的长度对列表中的元素排序）传给列表的 sort 方法。\nstrings &#x3D; [&#39;foo&#39;, &#39;card&#39;, &#39;bar&#39;, &#39;aaaa&#39;, &#39;abab&#39;]\n\n\nstrings.sort(key&#x3D;lambda x: len(set(list(x))))\nstrings\n\n\n\n\n[&#39;aaaa&#39;, &#39;foo&#39;, &#39;abab&#39;, &#39;bar&#39;, &#39;card&#39;]\n\nCurrying: Partial Argument Application（柯里化：部分参数应用）通过已有函数定义一个新的函数。\ndef add_numbers(x, y):\n    return x + y\n\n\nadd_five &#x3D; lambda y: add_numbers(5, y)\nadd_five(5)\n\n\n\n\n10\n\n也可以使用内建模块 functools 中的 partial 函数简化这种处理。\npartial?\n\n\nfrom functools import partial\nadd_five &#x3D; partial(add_numbers, 5)\n\nGenerators（生成器）通过一致的方式遍历序列，例如按行遍历文件中的内容或按元素遍历列表，这种特性是通过迭代器协议实现的。迭代器协议是一种令对象可遍历的通用方式。例如遍历一个字典的键：\nsome_dict &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;\nfor key in some_dict:\n    print(key)\n\na\nb\nc\n\nPython 先尝试根据 some_dict 生成一个迭代器：\ndict_iterator &#x3D; iter(some_dict)\ndict_iterator\n\n\n\n\n&lt;dict_keyiterator at 0x1df1f383ea8&gt;\n\n迭代器是一种用于在上下文中（如 for 循环）像 Python 解释器生成对象的对象。接受迭代器的方法包括大部分以列表或列表型对象为参数的方法，包括但不限于 min、max 和 sum，以及类型构造函数如 list 和 tuple：\nlist(dict_iterator)\n\n\n\n\n[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]\n\n生成器用于构造新的可遍历对象：生成器会返回一个多结果序列，在每个元素产生后暂停，直到接受下一个请求。如需创建生成器，只需将关键字 return 替换为 yield。\ndef squares(n&#x3D;10):\n    print(&#39;Generating squares from 1 to &#123;0&#125;&#39;.format(n ** 2))\n    for i in range(1, n + 1):\n        yield i ** 2\n\n当调用生成器时代码不会被真正执行。\ngen &#x3D; squares()\ngen\n\n\n\n\n&lt;generator object squares at 0x000001DF1F2CC408&gt;\n\n直到请求生成器中元素时代码才会被执行。\nfor x in gen:\n    print(x, end&#x3D;&#39; &#39;)\n\nGenerating squares from 1 to 100\n1 4 9 16 25 36 49 64 81 100 \n\nGenerator expresssions（生成器表达式）与列表推导式类似，可以用生成器表达式创建生成器，此时需要将列表推导式的 [] 改为 ()。\ngen &#x3D; (x ** 2 for x in range(100))\ngen\n\n\n\n\n&lt;generator object &lt;genexpr&gt; at 0x000001DF1F2CC390&gt;\n\n上述代码效果与下面的代码效果等价。\ndef _make_gen():\n    for x in range(100):\n        yield x ** 2\ngen &#x3D; _make_gen()\n\n也可作为参数传递给接受迭代器对象的函数。\nsum(x ** 2 for x in range(100))\n\n\n\n\n328350\n\ndict((i, i **2) for i in range(5))\n\n\n\n\n&#123;0: 0, 1: 1, 2: 4, 3: 9, 4: 16&#125;\n\nitertools module（itertools 模块）itertools 模块包含大多数数据算法的生成器集合。例如通过 groupby 根据任意函数的返回值（key）对任意序列中的元素（sub-iterator）进行分组（即返回 (key, sub-iterator) 元组）。\nimport itertools\nfirst_letter &#x3D; lambda x: x[0]\nnames &#x3D; [&#39;Alan&#39;, &#39;Adam&#39;, &#39;Wes&#39;, &#39;Will&#39;, &#39;Albert&#39;, &#39;Steven&#39;]\nfor letter, names in itertools.groupby(names, first_letter):\n    print(letter, list(names)) # names is a generator\n\nA [&#39;Alan&#39;, &#39;Adam&#39;]\nW [&#39;Wes&#39;, &#39;Will&#39;]\nA [&#39;Albert&#39;]\nS [&#39;Steven&#39;]\n\nErrors and Exception Handling（错误和异常处理）ValueError（输入参数值错误）：\nfloat(&#39;1.2345&#39;)\n\n\n\n\n1.2345\n\nfloat(&#39;something&#39;)\n\n\n---------------------------------------------------------------------------\n\nValueError                                Traceback (most recent call last)\n\n&lt;ipython-input-72-2649e4ade0e6&gt; in &lt;module&gt;\n----&gt; 1 float(&#39;something&#39;)\n\n\nValueError: could not convert string to float: &#39;something&#39;\n\n可以写入一个 try/except 代码段。\ndef attempt_float(x):\n    try:\n        return float(x)\n    except:\n        return x\n\n如果 attempt_float(x) 执行时出现异常，则执行 except 段的代码。\nattempt_float(&#39;1.2345&#39;)\n\n\n\n\n1.2345\n\nattempt_float(&#39;something&#39;)\n\n\n\n\n&#39;something&#39;\n\nTypeError（语法错误）：\nfloat((1, 2))\n\n\n---------------------------------------------------------------------------\n\nTypeError                                 Traceback (most recent call last)\n\n&lt;ipython-input-76-82f777b0e564&gt; in &lt;module&gt;\n----&gt; 1 float((1, 2))\n\n\nTypeError: float() argument must be a string or a number, not &#39;tuple&#39;\n\n可以通过将多个异常类型写成元组的方式同时捕获多个异常（小括号必不可少）：\ndef attempt_float(x):\n    try:\n        return float(x)\n    except (TypeError, ValueError):\n        return x\n\n\nattempt_float((1, 2))\n\n\n\n\n(1, 2)\n\n使用关键字 finally，当无论程序是否报错时都要执行该部分的代码。\nf &#x3D; open(path, &#39;w&#39;)\n\ntry:\n    write_to_file(f)\nfinally:\n    f.close()\n\n这样可以使 f 在程序结束后总能被关闭。\n可以使用 else 来执行当 try 代码块执行成功后才会执行的代码。\nf &#x3D; open(path, &#39;w&#39;)\n\ntry:\n    write_to_file(f)\nexcept:\n    print(&#39;Failed&#39;)\nelse:\n    print(&#39;Succeeded&#39;)\nfinally:\n    f.close()\n\nExceptions in IPython（IPython 中的异常）用 %run 执行脚本或语句时报错，IPython 会默认打印出完整的报错追溯。\n%run examples&#x2F;ipython_bug.py\n\n\n---------------------------------------------------------------------------\n\nAssertionError                            Traceback (most recent call last)\n\nE:\\Ranhui\\Onedrive\\OneDrive - ryanhui\\Memo\\Notes&amp;Materials\\pydata-book-2nd-edition\\examples\\ipython_bug.py in &lt;module&gt;\n     13     throws_an_exception()\n     14 \n---&gt; 15 calling_things()\n\n\nE:\\Ranhui\\Onedrive\\OneDrive - ryanhui\\Memo\\Notes&amp;Materials\\pydata-book-2nd-edition\\examples\\ipython_bug.py in calling_things()\n     11 def calling_things():\n     12     works_fine()\n---&gt; 13     throws_an_exception()\n     14 \n     15 calling_things()\n\n\nE:\\Ranhui\\Onedrive\\OneDrive - ryanhui\\Memo\\Notes&amp;Materials\\pydata-book-2nd-edition\\examples\\ipython_bug.py in throws_an_exception()\n      7     a = 5\n      8     b = 6\n----&gt; 9     assert(a + b == 10)\n     10 \n     11 def calling_things():\n\n\nAssertionError: \n\n可以使用 %xmode 命令控制上下文的数量。\nFiles and the Operating System（文件和操作系统）%pushd?\n\n\n%pushd book-materials\n\n[WinError 2] The system cannot find the file specified: &#39;book-materials&#39;\nE:\\Ranhui\\Onedrive\\OneDrive - ryanhui\\Memo\\Notes&amp;Materials\\pydata-book-2nd-edition\n\n\n\n\n\n[&#39;E:\\\\Ranhui\\\\Onedrive\\\\OneDrive - ryanhui\\\\Memo\\\\Notes&amp;Materials\\\\pydata-book-2nd-edition&#39;]\n\n打开文件。默认情况下文件是以只读模式 &#39;r&#39; 打开的，之后可以像处理列表一样处理文件。\npath &#x3D; &#39;examples&#x2F;segismundo.txt&#39;\nf &#x3D; open(path, encoding&#x3D;&#39;utf-8&#39;)\nf\n\n\n\n\n&lt;_io.TextIOWrapper name=&#39;examples/segismundo.txt&#39; mode=&#39;r&#39; encoding=&#39;utf-8&#39;&gt;\n\n遍历文件 f 的行内容。\nfor line in f:\n    pass\n\n行内容会在行结尾标识（EOL）完整的情况下从文件中全部读出。\nlines &#x3D; [x.rstrip() for x in open(path)]\nlines\n\n\n\n\n[&#39;Sue帽a el rico en su riqueza,&#39;,\n &#39;que m谩s cuidados le ofrece;&#39;,\n &#39;&#39;,\n &#39;sue帽a el pobre que padece&#39;,\n &#39;su miseria y su pobreza;&#39;,\n &#39;&#39;,\n &#39;sue帽a el que a medrar empieza,&#39;,\n &#39;sue帽a el que afana y pretende,&#39;,\n &#39;sue帽a el que agravia y ofende,&#39;,\n &#39;&#39;,\n &#39;y en el mundo, en conclusi贸n,&#39;,\n &#39;todos sue帽an lo que son,&#39;,\n &#39;aunque ninguno lo entiende.&#39;,\n &#39;&#39;]\n\n当使用 open 创建文件时，在操作结束后显式地关闭文件是非常重要的。\n\n\n\nf.close()\n\n\n\n\n&lt;_io.TextIOWrapper name=&#39;examples/segismundo.txt&#39; mode=&#39;r&#39; encoding=&#39;utf-8&#39;&gt;\n\n使用 with 语句，文件在 with 代码块结束后自动关闭。\nwith open(path) as f:\n    lines &#x3D; [x.rstrip() for x in f]\nlines\n\n\n\n\n[&#39;Sue帽a el rico en su riqueza,&#39;,\n &#39;que m谩s cuidados le ofrece;&#39;,\n &#39;&#39;,\n &#39;sue帽a el pobre que padece&#39;,\n &#39;su miseria y su pobreza;&#39;,\n &#39;&#39;,\n &#39;sue帽a el que a medrar empieza,&#39;,\n &#39;sue帽a el que afana y pretende,&#39;,\n &#39;sue帽a el que agravia y ofende,&#39;,\n &#39;&#39;,\n &#39;y en el mundo, en conclusi贸n,&#39;,\n &#39;todos sue帽an lo que son,&#39;,\n &#39;aunque ninguno lo entiende.&#39;,\n &#39;&#39;]\n\n如果以写入模式打开文件 f=open(path, &#39;w&#39;) ，一个新的文件会在对应的路径位置被创建，并覆盖路径下的同名文件。还有 &#39;x&#39; 文件模式，会创建可写文件，但在给定路径下存在同名文件就会写入失败。\n对于可读文件，最常用的方法是 read、seek 和 tell。read 返回文件中一定量字符，或在二进制模式打开的文件下读取简单的原生字节。\nf &#x3D; open(path)\nf.read(10)\n\n\n\n\n&#39;Sue帽a el r&#39;\n\nf2 &#x3D; open(path, &#39;rb&#39;)  # Binary mode\nf2.read(10)\n\n\n\n\nb&#39;Sue\\xc3\\xb1a el &#39;\n\nread 通过读取字节数来推进文件句柄的位置，tell 方法可以给出句柄当前的位置。\nf.tell()\n\n\n\n\n11\n\nf2.tell()\n\n\n\n\n10\n\n查看文件的默认编码。\nimport sys\nsys.getdefaultencoding()\n\n\n\n\n&#39;utf-8&#39;\n\nseek 方法可以将句柄位置改变到文件中特定的字节。\nf.seek(5)\nf.read(1)\n\n\n\n\n&#39;a&#39;\n\nf.close()\nf2.close()\n\n使用文件对象的 write 方法或 writelines 方法。\nwith open(&#39;examples&#x2F;tmp.txt&#39;, &#39;w&#39;) as handle:\n    handle.writelines(x for x in open(path) if len(x) &gt; 1)\nwith open(&#39;examples&#x2F;tmp.txt&#39;) as f:\n    lines &#x3D; f.readlines()\nlines\n\n\n\n\n[&#39;Sue帽a el rico en su riqueza,\\n&#39;,\n &#39;que m谩s cuidados le ofrece;\\n&#39;,\n &#39;sue帽a el pobre que padece\\n&#39;,\n &#39;su miseria y su pobreza;\\n&#39;,\n &#39;sue帽a el que a medrar empieza,\\n&#39;,\n &#39;sue帽a el que afana y pretende,\\n&#39;,\n &#39;sue帽a el que agravia y ofende,\\n&#39;,\n &#39;y en el mundo, en conclusi贸n,\\n&#39;,\n &#39;todos sue帽an lo que son,\\n&#39;,\n &#39;aunque ninguno lo entiende.\\n&#39;]\n\n删除文件。\nimport os\nos.remove(&#39;examples&#x2F;tmp.txt&#39;)\n\nBytes and Unicode with Files（字节与 Unicode 文件）with open(path) as f:\n    chars &#x3D; f.read(10)\nchars\n\n\n\n\n&#39;Sue帽a el r&#39;\n\nwith open(path, &#39;rb&#39;) as f:\n    data &#x3D; f.read(10)\ndata\n\n\n\n\nb&#39;Sue\\xc3\\xb1a el &#39;\n\n只有每个已编码的 Unicode 字符完整的情况下，才能解码。\ndata.decode(&#39;utf8&#39;)\n\n\n\n\n&#39;Sueña el &#39;\n\ndata[:4].decode(&#39;utf8&#39;)\n\n\n---------------------------------------------------------------------------\n\nUnicodeDecodeError                        Traceback (most recent call last)\n\n&lt;ipython-input-112-0ad9ad6a11bd&gt; in &lt;module&gt;\n----&gt; 1 data[:4].decode(&#39;utf8&#39;)\n\n\nUnicodeDecodeError: &#39;utf-8&#39; codec can&#39;t decode byte 0xc3 in position 3: unexpected end of data\n\n用 open 方法的选项参数 encoding 对文件进行转码。\nsink_path &#x3D; &#39;sink.txt&#39;\nwith open(path) as source:\n    with open(sink_path, &#39;xt&#39;, encoding&#x3D;&#39;utf-16&#39;) as sink:\n        sink.write(source.read())\nwith open(sink_path, encoding&#x3D;&#39;utf-16&#39;) as f:\n    print(f.read(10))\n\nSue帽a el r\n\nos.remove(sink_path)\n\n除二进制模式，在打开文件时使用 seek 要小心，当文件句柄位置恰好在一个 Unicode 符号的字节中间时，后续读取会导致错误。\nf &#x3D; open(path)\nf.read(5)\n\n\n\n\n&#39;Sue帽a&#39;\n\nf.seek(4)\nf.read(1)\n\n\n\n\n&#39;盿&#39;\n\nf.close()\n\n\n%popd\n\nUsageError: %popd on empty stack\n\n","slug":"Python-内建数据结构，函数和文件系统","date":"2019-07-15T09:12:05.000Z","categories_index":"笔记,Python","tags_index":"python,读书笔记","author_index":"Ryanhui"},{"id":"e9467e98877499c2145d4cfcc50df70b","title":"Python 语言基础，IPython 和 Jupyter Notebook","content":"Python 语言基础，IPython 和 Jupyter Notebook 学习笔记。\n\nThe Python Interpreter$ python\nPython 3.6.0 | packaged by conda-forge | (default, Jan 13 2017, 23:17:12)\n[GCC 4.8.2 20140120 (Red Hat 4.8.2-15)] on linux\nType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.\n&gt;&gt;&gt; a &#x3D; 5\n&gt;&gt;&gt; print(a)\n5\n\nprint(&#39;Hello world&#39;)\n\n$ python hello_world.py\nHello world\n\n$ ipython\nPython 3.6.0 | packaged by conda-forge | (default, Jan 13 2017, 23:17:12)\nType &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.\n\nIPython 5.1.0 -- An enhanced Interactive Python.\n?         -&gt; Introduction and overview of IPython&#39;s features.\n%quickref -&gt; Quick reference.\nhelp      -&gt; Python&#39;s own help system.\nobject?   -&gt; Details about &#39;object&#39;, use &#39;object??&#39; for extra details.\n\nIn [1]: %run hello_world.py\nHello world\n\nIn [2]:\n\nIPython BasicsRunning the IPython Shell$ ipython\nPython 3.6.0 | packaged by conda-forge | (default, Jan 13 2017, 23:17:12)\nType &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.\n\nIPython 5.1.0 -- An enhanced Interactive Python.\n?         -&gt; Introduction and overview of IPython&#39;s features.\n%quickref -&gt; Quick reference.\nhelp      -&gt; Python&#39;s own help system.\nobject?   -&gt; Details about &#39;object&#39;, use &#39;object??&#39; for extra details.\n\nIn [1]: a &#x3D; 5\n\nIn [2]: a\nOut[2]: 5\n\n\nimport numpy as np\ndata &#x3D; &#123;i : np.random.randn() for i in range(7)&#125;\ndata\n\n\n\n\n&#123;0: -0.20470765948471295,\n 1: 0.47894333805754824,\n 2: -0.5194387150567381,\n 3: -0.55573030434749,\n 4: 1.9657805725027142,\n 5: 1.3934058329729904,\n 6: 0.09290787674371767&#125;\n\n&gt;&gt;&gt; from numpy.random import randn\n&gt;&gt;&gt; data &#x3D; &#123;i : randn() for i in range(7)&#125;\n&gt;&gt;&gt; print(data)\n&#123;0: -1.5948255432744511, 1: 0.10569006472787983, 2: 1.972367135977295,\n3: 0.15455217573074576, 4: -0.24058577449429575, 5: -1.2904897053651216,\n6: 0.3308507317325902&#125;\n\nRunning the Jupyter Notebook$ jupyter notebook\n[I 15:20:52.739 NotebookApp] Serving notebooks from local directory:\n&#x2F;home&#x2F;wesm&#x2F;code&#x2F;pydata-book\n[I 15:20:52.739 NotebookApp] 0 active kernels\n[I 15:20:52.739 NotebookApp] The Jupyter Notebook is running at:\nhttp:&#x2F;&#x2F;localhost:8888&#x2F;\n[I 15:20:52.740 NotebookApp] Use Control-C to stop this server and shut down\nall kernels (twice to skip confirmation).\nCreated new window in existing browser session.\n\nTab 补全变量名补全\nIn [1]: an_apple &#x3D; 27\n\nIn [2]: an_example &#x3D; 42\n\nIn [3]: an\n\n方法补全\nIn [3]: b &#x3D; [1, 2, 3]\n\nIn [4]: b.\n\n模块补全\nIn [1]: import datetime\n\nIn [2]: datetime.\n\n路径补全\nIn [7]: datasets&#x2F;movielens&#x2F;\n\nIntrospection（内省）In [8]: b &#x3D; [1, 2, 3]\n\nIn [9]: b?\nType:       list\nString Form:[1, 2, 3]\nLength:     3\nDocstring:\nlist() -&gt; new empty list\nlist(iterable) -&gt; new list initialized from iterable&#39;s items\n\nIn [10]: print?\nDocstring:\nprint(value, ..., sep&#x3D;&#39; &#39;, end&#x3D;&#39;\\n&#39;, file&#x3D;sys.stdout, flush&#x3D;False)\n\nPrints the values to a stream, or to sys.stdout by default.\nOptional keyword arguments:\nfile:  a file-like object (stream); defaults to the current sys.stdout.\nsep:   string inserted between values, default a space.\nend:   string appended after the last value, default a newline.\nflush: whether to forcibly flush the stream.\nType:      builtin_function_or_method\n\ndef add_numbers(a, b):\n    &quot;&quot;&quot;\n    Add two numbers together\n\n    Returns\n    -------\n    the_sum : type of arguments\n    &quot;&quot;&quot;\n    return a + b\n\nIn [11]: add_numbers?\nSignature: add_numbers(a, b)\nDocstring:\nAdd two numbers together\n\nReturns\n-------\nthe_sum : type of arguments\nFile:      &lt;ipython-input-9-6a548a216e27&gt;\nType:      function\n\nIn [12]: add_numbers??\nSignature: add_numbers(a, b)\nSource:\ndef add_numbers(a, b):\n    &quot;&quot;&quot;\n    Add two numbers together\n\n    Returns\n    -------\n    the_sum : type of arguments\n    &quot;&quot;&quot;\n    return a + b\nFile:      &lt;ipython-input-9-6a548a216e27&gt;\nType:      function\n\nIn [13]: np.*load*?\nnp.__loader__\nnp.load\nnp.loads\nnp.loadtxt\nnp.pkgload\n\nThe %run Commanddef f(x, y, z):\n    return (x + y) &#x2F; z\n\na &#x3D; 5\nb &#x3D; 6\nc &#x3D; 7.5\n\nresult &#x3D; f(a, b, c)\n\nIn [14]: %run ipython_script_test.py\n\nIn [15]: c\nOut [15]: 7.5\n\nIn [16]: result\nOut[16]: 1.4666666666666666\n\n&gt;&gt;&gt; %load ipython_script_test.py\n\n    def f(x, y, z):\n        return (x + y) &#x2F; z\n\n    a &#x3D; 5\n    b &#x3D; 6\n    c &#x3D; 7.5\n\n    result &#x3D; f(a, b, c)\n\nInterrupting running codeExecuting Code from the Clipboard（执行剪贴板中的程序）x &#x3D; 5\ny &#x3D; 7\nif x &gt; 5:\n    x +&#x3D; 1\n\n    y &#x3D; 8\n\nIn [17]: %paste\nx &#x3D; 5\ny &#x3D; 7\nif x &gt; 5:\n    x +&#x3D; 1\n\n    y &#x3D; 8\n## -- End pasted text --\n\nIn [18]: %cpaste\nPasting code; enter &#39;--&#39; alone on the line to stop or use Ctrl-D.\n:x &#x3D; 5\n:y &#x3D; 7\n:if x &gt; 5:\n:    x +&#x3D; 1\n:\n:    y &#x3D; 8\n:--\n\nTerminal Keyboard Shortcuts（终端快捷键IPython）About Magic Commands（魔术命令）使用 %timeit 检查语句的执行时间。\nIn [20]: a &#x3D; np.random.randn(100, 100)\n\nIn [20]: %timeit np.dot(a, a)\n10000 loops, best of 3: 20.9 µs per loop\n\n魔术命令查看命令行。\nIn [21]: %debug?\nDocstring:\n::\n\n  %debug [--breakpoint FILE:LINE] [statement [statement ...]]\n\nActivate the interactive debugger.\n\nThis magic command support two ways of activating debugger.\nOne is to activate debugger before executing code.  This way, you\ncan set a break point, to step through the code from the point.\nYou can use this mode by giving statements to execute and optionally\na breakpoint.\n\nThe other one is to activate debugger in post-mortem mode.  You can\nactivate this mode simply running %debug without any argument.\nIf an exception has just occurred, this lets you inspect its stack\nframes interactively.  Note that this will always work only on the last\ntraceback that occurred, so you must call this quickly after an\nexception that you wish to inspect has fired, because if another one\noccurs, it clobbers the previous one.\n\nIf you want IPython to automatically do this on every exception, see\nthe %pdb magic for more details.\n\npositional arguments:\n  statement             Code to run in debugger. You can omit this in cell\n                        magic mode.\n\noptional arguments:\n  --breakpoint &lt;FILE:LINE&gt;, -b &lt;FILE:LINE&gt;\n                        Set break point at LINE in FILE.\n\n&#96;&#96;&#96;                        \n\n*自动魔术*：不加 &#96;%&#96; 的魔法函数。通过 &#96;%automagic&#96; 启用。\n\n可赋值的魔术函数：\n\n&#96;&#96;&#96;python\nIn [22]: %pwd\nOut[22]: &#39;&#x2F;home&#x2F;wesm&#x2F;code&#x2F;pydata-book\n\nIn [23]: foo &#x3D; %pwd\n\nIn [24]: foo\nOut[24]: &#39;&#x2F;home&#x2F;wesm&#x2F;code&#x2F;pydata-book&#39;\n\nMatplotlib Integration（matplotlib 集成）In [26]: %matplotlib\nUsing matplotlib backend: Qt4Agg\n\nIn [26]: %matplotlib inline\n\nPython Language Basics（Python 语言基础）Language Semantics（语言语义）Indentation, not braces（缩进）冒号表示缩进代码块的开始，使用四个空格作为默认缩进。\nfor x in array:\n    if x &lt; pivot:\n        less.append(x)\n    else:\n        greater.append(x)\n\n使用分号分割一行中的多条语句。\na &#x3D; 5; b &#x3D; 6; c &#x3D; 7\n\nEverything is an object（一切皆为对象）Comments（注释）results &#x3D; []\nfor line in file_handle:\n    # keep the empty lines for now\n    # if len(line) &#x3D;&#x3D; 0:\n    #   continue\n    results.append(line.replace(&#39;foo&#39;, &#39;bar&#39;))\n\nprint(&quot;Reached this line&quot;)  # Simple status report\n\nFunction and object method calls（函数和对象方法调用）将返回值赋给一个变量。\nresult &#x3D; f(x, y, z)\ng()\n\n方法：Python 对象内置函数。\nobj.some_method(x, y, z)\n\n函数传参。\nresult &#x3D; f(a, b, c, d&#x3D;5, e&#x3D;&#39;foo&#39;)\n\nVariables and argument passing（变量和参数传递）a &#x3D; [1, 2, 3]\n\n\nb &#x3D; a\n\na 和 b 是指向相同的对象。\na.append(4)\nb\n\n\n\n\n[1, 2, 3, 4]\n\n将对象传递到函数中时，不会改变在原有命名空间中对象和变量间的绑定。因此，可以用函数更改对象的内部值而无需返回任何对象。\ndef append_element(some_list, element):\n    some_list.append(element)\n\nIn [27]: data &#x3D; [1, 2, 3]\n\nIn [28]: append_element(data, 4)\n\nIn [29]: data\nOut[29]: [1, 2, 3, 4]\n\nDynamic references, strong types（动态引用，强类型）Python 对象引用不涉及类型。变量对于对象只是特定命名空间中的名称，类型信息储存于对象自身当中。\na &#x3D; 5\ntype(a)\n\n\n\n\nint\n\na &#x3D; &#39;foo&#39;\ntype(a)\n\n\n\n\nstr\n\nPython 是强类型语言，所有对象都拥有一个指定的类型。\n&#39;5&#39; + 5\n\n---------------------------------------------------------------------------\n\nTypeError                                 Traceback (most recent call last)\n\n&lt;ipython-input-17-4dd8efb5fac1&gt; in &lt;module&gt;\n----&gt; 1 &#39;5&#39; + 5\n    \n\nTypeError: can only concatenate str (not &quot;int&quot;) to str\n\n仅有特定、明显情况下，类型可以隐式（自动）地转换。\na &#x3D; 4.5\nb &#x3D; 2\n# String formatting, to be visited later\nprint(&#39;a is &#123;0&#125;, b is &#123;1&#125;&#39;.format(type(a), type(b)))\na &#x2F; b\n\nisinstance 函数，检查对象是否为特定类型的实例。\na &#x3D; 5\nisinstance(a, int)\n\n检查对象类型是否包含在元组的类型中。\na &#x3D; 5; b &#x3D; 4.5\nisinstance(a, (int, float))\nisinstance(b, (int, float))\n\nAttributes and methods（属性与方法）属性：对象内部存储的其他对象。\n方法：与对象内部对象有关的函数。\nIn [1]: a &#x3D; &#39;foo&#39;\n\nIn [2]: a.&lt;Press Tab&gt;\na.capitalize  a.format      a.isupper     a.rindex      a.strip\na.center      a.index       a.join        a.rjust       a.swapcase\na.count       a.isalnum     a.ljust       a.rpartition  a.title\na.decode      a.isalpha     a.lower       a.rsplit      a.translate\na.encode      a.isdigit     a.lstrip      a.rstrip      a.upper\na.endswith    a.islower     a.partition   a.split       a.zfill\na.expandtabs  a.isspace     a.replace     a.splitlines\na.find        a.istitle     a.rfind       a.startswith\n\ngetattr 函数获取对象的属性和方法：\na &#x3D; &#39;foo&#39;\n\n\ngetattr(a, &#39;split&#39;)\n\nDuck typing（鸭子类型）不去关心对象的具体类型，而关心其是否拥有某个特殊方法或行为。\n因此可以验证一个对象是否可以迭代。\ndef isiterable(obj):\n    try:\n        iter(obj)\n        return True\n    except TypeError: # not iterable\n        return False\n\n\nisiterable(&#39;a string&#39;)\n\n\nisiterable([1, 2, 3])\n\n\nisiterable(5)\n\n---------------------------------------------------------------------------\n\nNameError                                 Traceback (most recent call last)\n\n&lt;ipython-input-18-1fb743da1716&gt; in &lt;module&gt;\n----&gt; 1 isiterable(5)\n    \n\nNameError: name &#39;isiterable&#39; is not defined\n\n需要编写接受多种类型输入的函数时，可以使用此功能，将不可迭代的对象转换为列表。\nif not isinstance(x, list) and isiterable(x):\n    x &#x3D; list(x)\n\nImports（导入）模块就是 .py 后缀的 Python 文件，假设有以下模块：\n# some_module.py\nPI &#x3D; 3.14159\n\ndef f(x):\n    return x + 2\n\ndef g(a, b):\n    return a + b\n\n从同一文件路径下的文件链接到该模块中定义的变量和函数。\nimport some_module\nresult &#x3D; some_module.f(5)\npi &#x3D; some_module.PI\n\n或者\nfrom some_module import f, g, PI\nresult &#x3D; g(5, PI)\n\n使用 as 关键字，对导入模块赋予不同变量名\nimport some_module as sm\nfrom some_module import PI as pi, g as gf\n\nr1 &#x3D; sm.f(pi)\nr2 &#x3D; gf(6, pi)\n\nBinary operators and comparisons（二元运算符和比较运算）二元数学运算。\n5 - 7\n12 + 21.5\n5 &lt;&#x3D; 2\n\n检查两个变量名是否指向同一个对象（is 关键字）。\na &#x3D; [1, 2, 3]\nb &#x3D; a\na is b\n\nlist 函数总是创建一个新的列表，所以变量 a 和 c 指向不同的对象。\nc &#x3D; list(a)\na is not c    # 检查两个对象不是相同对象\n\n\na &#x3D;&#x3D; c\n\nis 和 is not 常用于检查一个变量是否为 None。\na &#x3D; None\na is None\n\nMutable and immutable objects（可变对象和不可变对象）大部分对象如列表、字典都是可变对象，可变对象中包含的对象和值是可以修改的。\na_list &#x3D; [&#39;foo&#39;, 2, [4, 5]]\na_list[2] &#x3D; (3, 4)\na_list\n\n字符串、元组对象是不可变的。\na_tuple &#x3D; (3, 5, (4, 5))\na_tuple[1] &#x3D; &#39;four&#39;\n\nScalar Types（标量类型）Python 的标准库中拥有一个小的内建类型集合，用来处理数值数据、字符串、布尔值以及日期和时间。这类的“单值”类型有时候被称为标量类型。\nNumeric types（数值类型）基础数字类型 int。\nival &#x3D; 17239871\nival ** 6\n\n基础数字类型 float，每一个浮点数都是双精度64位数值。\nfval &#x3D; 7.243\nfval2 &#x3D; 6.78e-5\n\n整数除法将结果自动转为浮点数。\n3 &#x2F; 2\n\n整除操作：\n3 &#x2F;&#x2F; 2\n\nStrings（字符串）使用单引号 &#39; 或双引号 &quot; 创建字符串。\na &#x3D; &#39;one way of writing a string&#39;\nb &#x3D; &quot;another way&quot;\n\n含换行的字符串（三个单引号 &#39;&#39;&#39; 或双引号 &quot;&quot;&quot;）\nc &#x3D; &quot;&quot;&quot;\nThis is a longer string that\nspans multiple lines\n&quot;&quot;&quot;\n\n计算 c 的回车符。（注意包括 &quot;&quot;&quot; 后的换行以及 lines 后的换行）\nc.count(&#39;\\n&#39;)\n\n字符串无法修改。\na &#x3D; &#39;this is a string&#39;\na[10] &#x3D; &#39;f&#39;\nb &#x3D; a.replace(&#39;string&#39;, &#39;longer string&#39;)\nb\n\n\na\n\n用 str 函数转成字符串。\na &#x3D; 5.6\ns &#x3D; str(a)\nprint(s)\n\n字符串可看作列表和元组外的另一个序列。\ns &#x3D; &#39;python&#39;\nlist(s)\ns[:3]    # 对 s 切片\n\n转义符号 \\。\ns &#x3D; &#39;12\\\\34&#39;\nprint(s)\n\n在字符串前加一个前缀符号 r 表明这些字符是原生字符。（特殊符号不会被转义）\ns &#x3D; r&#39;this\\has\\no\\special\\characters&#39;\ns\n\n字符串的结合。\na &#x3D; &#39;this is the first half &#39;\nb &#x3D; &#39;and this is the second half&#39;\na + b\n\n字符串格式化，在下例中：\n\n&#123;0:.2f&#125; 表示将第一个参数格式化为2位小数的浮点数\n&#123;1:s&#125; 表示将第二个参数格式化为字符串\n&#123;2:d&#125; 表示将第三个参数格式化为整数\n\ntemplate &#x3D; &#39;&#123;0:.2f&#125; &#123;1:s&#125; are worth US$&#123;2:d&#125;&#39;\n\n将含有参数的序列传给字符串的 format 方法。\ntemplate.format(4.5560, &#39;Argentine Pesos&#39;, 1)\n\n---------------------------------------------------------------------------\n\nNameError                                 Traceback (most recent call last)\n\n&lt;ipython-input-19-ab8588df4260&gt; in &lt;module&gt;\n----&gt; 1 template.format(4.5560, &#39;Argentine Pesos&#39;, 1)\n    \n\nNameError: name &#39;template&#39; is not defined\n\nBytes and Unicode（字节与 Unicode）val &#x3D; &quot;español&quot;\nval\n\n使用 encode 方法将此 Unicode 字符串转换为 UTF-8 字节。\nval_utf8 &#x3D; val.encode(&#39;utf-8&#39;)\nval_utf8\n\n\ntype(val_utf8)\n\n使用 decode 方法解码。\nval_utf8.decode(&#39;utf-8&#39;)\n\n一些不同的编码：\nval.encode(&#39;latin1&#39;)\nval.encode(&#39;utf-16&#39;)\nval.encode(&#39;utf-16le&#39;)\n\n在字符串前加前缀 b 定义字符文本。\nbytes_val &#x3D; b&#39;this is bytes&#39;\nbytes_val\n\n\ndecoded &#x3D; bytes_val.decode(&#39;utf8&#39;)\ndecoded  # this is str (Unicode) now\n\nBooleans（布尔值）True and True\nFalse or True\n\nType casting（类型转换）s &#x3D; &#39;3.14159&#39;\nfval &#x3D; float(s)\ntype(fval)\n\n\nint(fval)\n\n\nbool(fval)\n\n\nbool(0)\n\nNonea &#x3D; None\na is None\n\n\nb &#x3D; 5\nb is not None\n\nNone 作为函数参数默认值。\ndef add_and_maybe_multiply(a, b, c&#x3D;None):\n    result &#x3D; a + b\n\n    if c is not None:\n        result &#x3D; result * c\n\n    return result\n\nNone 是 NoneType 类型的唯一实例。\ntype(None)\n\nDates and times（日期、时间）Python 内建的 datetime 模块与 datetime 类型：\nfrom datetime import datetime, date, time\ndt &#x3D; datetime(2011, 10, 29, 20, 30, 21)\ndt.day\n\n\ndt.minute\n\n获取 datetime 实例的 date 和 time 对象。\ndt.date()\n\n\ndt.time()\n\n将 datetime 转换为字符串。\ndt.strftime(&#39;%m&#x2F;%d&#x2F;%Y %H:%M&#39;)\n\n将字符串转换为 datetime 对象。\ndatetime.strptime(&#39;20091031&#39;, &#39;%Y%m%d&#39;)\n\n替换。\ndt.replace(minute&#x3D;0, second&#x3D;0)\n\ndatetime.datetime 是不可变类型，以上方法均是产生新的变量。\n两个不同 datetime 间的运算会产生一个 datetime.timedelta 对象。\ndt2 &#x3D; datetime(2011, 11, 15, 22, 30)\ndelta &#x3D; dt2 - dt\ndelta\n\n\ntype(delta)\n\n将 timedelta 加到 datetime 上。\ndt\n\n\ndt + delta\n\nControl Flow（控制流）if, elif, and elsex &#x3D; 10\n\nif x &lt; 0:\n    print(&quot;It&#39;s negative&quot;)\n\n一个 if 语句可以接多个 elif 代码块和一个 else 代码块，若所有的 elif 均为 False 则执行 else 代码块。如果某个条件为 True，则后面的 elif 和 else 代码块则不会执行。\nif x &lt; 0:\n    print(&quot;It&#39;s negative&quot;)\nelif x &#x3D;&#x3D; 0:\n    print(&#39;Equal to zero&#39;)\nelif 0 &lt; x &lt; 5:\n    print(&#39;Positive but smaller than 5&#39;)\nelse:\n    print(&#39;Positive and larger than or equal to 5&#39;)\n\n条件判断时，判断顺序是从左到右且 and 和 or 两侧的条件会有“短路”现象。如下例中，c &gt; d 不会被判断。\na &#x3D; 5; b &#x3D; 7\nc &#x3D; 8; d &#x3D; 4\nif a &lt; b or c &gt; d:\n    print(&#39;Made it&#39;)\n\n链式比较。\n4 &gt; 3 &gt; 2 &gt; 1\n\nfor loops（for 循环）标准形式：\nfor value in collection:\n    # do something with value\n\n使用 continue 关键字跳过 continue 后面的代码并进入下一次循环。\nsequence &#x3D; [1, 2, None, 4, None, 5]\ntotal &#x3D; 0\nfor value in sequence:\n    if value is None:\n        continue\n    total +&#x3D; value\ntotal\n\n使用 break 关键字结束循环。\nsequence &#x3D; [1, 2, 0, 4, 6, 5, 2, 1]\ntotal_until_5 &#x3D; 0\nfor value in sequence:\n    if value &#x3D;&#x3D; 5:\n        break\n    total_until_5 +&#x3D; value\ntotal_until_5\n\nbreak 关键字仅结束最内层的 for 循环。\nfor i in range(4):\n    for j in range(4):\n        if j &gt; i:\n            break\n        print((i, j))\n\n(0, 0)\n(1, 0)\n(1, 1)\n(2, 0)\n(2, 1)\n(2, 2)\n(3, 0)\n(3, 1)\n(3, 2)\n(3, 3)\n\n如果迭代的对象是一个序列（元组或列表），它们可以在 for 循环中拆包成为变量。\nfor a, b, c in iterator:\n    # do something\n\nwhile loops（while 循环）while 循环在条件不成立时或以 break 结尾时停止。\nx &#x3D; 256\ntotal &#x3D; 0\nwhile x &gt; 0:\n    if total &gt; 500:\n        break\n    total +&#x3D; x\n    x &#x3D; x &#x2F;&#x2F; 2\n\npasspass 就是表示“什么都不做”的语句，可以作为还没有实现代码的占位符。\nif x &lt; 0:\n    print(&#39;negative!&#39;)\nelif x &#x3D;&#x3D; 0:\n    # TODO: put something smart here\n    pass\nelse:\n    print(&#39;positive!&#39;)\n\nrangerange 函数返回一个迭代器，该迭代器生成一个等差数列。\nrange(10)\n\n\n\n\nrange(0, 10)\n\nlist(range(10))\n\n\n\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n传参给 range 函数起始、结尾和步进（可以是负的）， range 函数产生的整数包含起始但不含结尾。\nlist(range(0, 20, 2))\n\n\n\n\n[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n\nlist(range(5, 0, -1))\n\n\n\n\n[5, 4, 3, 2, 1]\n\n根据序列的索引遍历序列。\nseq &#x3D; [1, 2, 3, 4]\nfor i in range(len(seq)):\n    val &#x3D; seq[i]\nprint(val)\n\n4\n\nsum &#x3D; 0\nfor i in range(100000):\n    # % 是求模操作符\n    if i % 3 &#x3D;&#x3D; 0 or i % 5 &#x3D;&#x3D; 0:\n        sum +&#x3D; i\n\nTernary expressions（三元表达式）将一个 if-else 语句结合成一行代码。\nvalue &#x3D; true时执行 if 条件 else false时执行\n\n\nx &#x3D; 5\n&#39;Non-negative&#39; if x &gt;&#x3D; 0 else &#39;Negative&#39;\n\n\n\n\n&#39;Non-negative&#39;\n\n注：在 Anaconda 环境下正确配置 VSCode正确下载安装 Anaconda 后，在 VSCode 中直接执行 Python 脚本第一次总会出现找不到模块的问题，发现是由于配置不当而导致的。查阅官方文档后，得出解决方法如下：\n\n安装 VSCode Python 插件。\n在 Anaconda command prompt 中输入：code &quot;work-folder&quot;\n等待 VSCode 执行即可。\n\n","slug":"Python-语言基础，IPython-和-Jupyter-Notebook","date":"2019-07-15T09:03:24.000Z","categories_index":"笔记,Python","tags_index":"python,读书笔记","author_index":"Ryanhui"},{"id":"0e4234a4caab3caa3ea203d33af78e67","title":"Python 数据分析与可视化动手学：泡沫铝应力应变关系实验数据处理（线性回归）","content":"观察数据、导入数据、划分特征和标签、划分训练集和测试集、构建模型，模型可视化\nBilibili视频教程：同济子豪兄\n\n第1步：导入数据分析库pandas，数据可视化库matplotlib%matplotlib inline是Ipython的魔法函数，其作用是使matplotlib绘制的图像嵌入在juptyer notebook的单元格里\nimport pandas as pd\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\n第2步：导入数据集，查看数据集# 导入数据集，筛选压力值在 1000N~10000N 的数据\ndataset &#x3D; pd.read_excel(&#39;.&#x2F;2#.xls&#39;)\ndataset &#x3D; dataset[(dataset[&quot;试验力(N)&quot;]&lt;10000) &amp; (dataset[&quot;试验力(N)&quot;]&gt;1000)]\ndataset.head(10)\n\ntype(dataset)\n\npandas.core.frame.DataFrame\n\ndataset.shape\n\n(144, 7)\n\ndataset.columns\n\nIndex([&#39;试验力(N)&#39;, &#39;变形1(mm)&#39;, &#39;变形2(mm)&#39;, &#39;位移(mm)&#39;, &#39;横梁速度(mm&#x2F;min)&#39;, &#39;时间(ms)&#39;,\n       &#39;温度&#39;],\n      dtype&#x3D;&#39;object&#39;)\n\ndataset.info()\n\n&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;\nInt64Index: 144 entries, 545 to 688\nData columns (total 7 columns):\n试验力(N)          144 non-null float64\n变形1(mm)         144 non-null int64\n变形2(mm)         144 non-null int64\n位移(mm)          144 non-null float64\n横梁速度(mm&#x2F;min)    144 non-null int64\n时间(ms)          144 non-null int64\n温度              144 non-null int64\ndtypes: float64(2), int64(5)\nmemory usage: 9.0 KB\n\n\n# 查看数据集统计特征\ndataset.describe()\n\n试验力(N)变形1(mm)变形2(mm)位移(mm)横梁速度(mm/min)时间(ms)温度count144.000000144.0144.0144.000000144.0144.000000144.0mean5933.1076390.00.03.313668-6.033070.1597220.0std2780.4992530.00.00.2237330.02251.1229360.0min1002.0000000.00.02.931965-6.029234.0000000.025%3452.1250000.00.03.121751-6.031129.2500000.050%6279.5000000.00.03.311385-6.033039.5000000.075%8387.2500000.00.03.499875-6.034937.5000000.0max9975.5000000.00.03.700565-6.036953.0000000.0\n\n第3步：提取特征提取特征：位移 提取标签：试验力\nfeature_columns &#x3D; [&#39;位移(mm)&#39;]\nlabel_column &#x3D; [&#39;试验力(N)&#39;]\n\nfeatures &#x3D; dataset[feature_columns]\nlabel &#x3D; dataset[label_column]\n\nfeatures.head(10)\n\n位移(mm)5452.9319655462.9377605472.9438605482.9478255492.9539255502.9578905512.9636855522.9716155532.9755805542.979545\n\ntype(features)\n\npandas.core.frame.DataFrame\n\nlabel.head(10)\n\n试验力(N)5451002.05461059.05471119.05481159.55491203.05501256.05511321.55521387.55531455.55541502.0\n\nX &#x3D; features.values\n\nY &#x3D; label.values\n\n第4步：建立模型拆分数据，四分之三的数据作为训练集，四分之一的数据作为测试集\nfrom sklearn.model_selection import train_test_split\nX_train, X_test, Y_train, Y_test &#x3D; train_test_split( X, Y, test_size &#x3D; 1&#x2F;4, random_state &#x3D; 0) \n\n用训练集的数据进行训练\nfrom sklearn.linear_model import LinearRegression\nregressor &#x3D; LinearRegression()\nregressor &#x3D; regressor.fit(X_train, Y_train)\n\n对测试集进行预测\nY_init &#x3D; regressor.predict(X_train)\nY_pred &#x3D; regressor.predict(X_test)\n\n可视化\n# 散点图：红色点表示训练集的点\nplt.scatter(X_train , Y_train, color &#x3D; &#39;red&#39;)\n# 线图：蓝色线表示由训练集训练出的线性回归模型\nplt.plot(X_train , Y_init, color &#x3D;&#39;blue&#39;)\nplt.show()\n\n\n# 散点图：红色点表示测试集的点\nplt.scatter(X_test , Y_test, color &#x3D; &#39;red&#39;)\n# 线图：蓝色线表示对测试集进行预测的结果\nplt.plot(X_test , Y_pred, color &#x3D;&#39;blue&#39;)\nplt.show()\n\n\n","slug":"数据分析与可视化动手学：泡沫铝应力应变关系（线性回归）","date":"2019-06-10T07:55:57.000Z","categories_index":"动手学,Python","tags_index":"动手学,python,Pandas,数据分析","author_index":"Ryanhui"},{"id":"e09f109ae9c19348b4ba2eebea2c785e","title":"HTML 动手学（3）","content":"Codecademy HTML 教程学习笔记\n\nStyling Text（格式文本)使用 HTML 标识符给文字添加格式：\n\n使用 &lt;em&gt; 标识符表示斜体。\n使用 &lt;strong&gt; 标识符表示加粗。\n\n&lt;p&gt;&lt;strong&gt;The Nile River&lt;&#x2F;strong&gt; is the &lt;em&gt;longest&lt;&#x2F;em&gt; river in the world, measuring over 6,850 kilometers long (approximately 4,260 miles).&lt;&#x2F;p&gt;\n\n上述代码在网页中显示为：\nThe Nile River is the longest river in the world, measuring over 6,850 kilometers long (approximately 4,260 miles).\n\nLine Breaks（断行）使用 &lt;br&gt; 将一段文字分为多行。\n&lt;p&gt;The Nile River is the longest river &lt;br&gt; in the world, measuring over 6,850 &lt;br&gt; kilometers long (approximately 4,260 &lt;br&gt; miles).&lt;&#x2F;p&gt;\n\n上述代码在网页中显示为：\nThe Nile River is the longest river  in the world, measuring over 6,850  kilometers long (approximately 4,260  miles).\n\n注意：&lt;br&gt; 仅有开始标识符，并无结束标识符。\n连续使用2个断行符以表示分段。\n&lt;p&gt;The brown bear (&lt;em&gt;Ursus arctos&lt;&#x2F;em&gt;) is native to parts of northern Eurasia and North America. Its conservation status is currently &lt;strong&gt;Least Concern&lt;&#x2F;strong&gt;.&lt;br&gt;&lt;br&gt; There are many subspecies within the brown bear species, including the Atlas bear and the Himalayan brown bear.&lt;&#x2F;p&gt;\n\n上述代码在网页中显示为：\nThe brown bear (Ursus arctos) is native to parts of northern Eurasia and North America. Its conservation status is currently Least Concern. There are many subspecies within the brown bear species, including the Atlas bear and the Himalayan brown bear.\n\nUnordered Lists（无序列表）使用 &lt;ul&gt; 标识符建立一个无序列表。\n&lt;ul&gt; 中不能包含纯文本，列表中的每个元素应包含在 &lt;li&gt; 标识符中。&lt;li&gt; 标识符表示列表元素（list item）标识符。\n&lt;ul&gt;\n  &lt;li&gt;Limes&lt;&#x2F;li&gt;\n  &lt;li&gt;Tortillas&lt;&#x2F;li&gt;\n  &lt;li&gt;Chicken&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\n上述代码在网页中显示为：\n\n  Limes\n  Tortillas\n  Chicken\n\n\nOrdered Lists（有序列表）使用 &lt;ol&gt; 标识符建立一个有序列表，列表中的每个元素应包含在 &lt;li&gt; 标识符中。\n&lt;ol&gt;\n  &lt;li&gt;Preheat the oven to 350 degrees.&lt;&#x2F;li&gt;\n  &lt;li&gt;Mix whole wheat flour, baking soda, and salt.&lt;&#x2F;li&gt;\n  &lt;li&gt;Cream the butter, sugar in separate bowl.&lt;&#x2F;li&gt;\n  &lt;li&gt;Add eggs and vanilla extract to bowl.&lt;&#x2F;li&gt;\n&lt;&#x2F;ol&gt;\n\n上述代码在网页中显示为：\n\n  Preheat the oven to 350 degrees.\n  Mix whole wheat flour, baking soda, and salt.\n  Cream the butter, sugar in separate bowl.\n  Add eggs and vanilla extract to bowl.\n","slug":"HTML-动手学（3）","date":"2019-05-30T13:06:54.000Z","categories_index":"动手学,HTML","tags_index":"动手学,HTML,前端开发","author_index":"Ryanhui"},{"id":"75b57b7c6ee96ef2fdb9b668a3aa782f","title":"HTML 动手学（2）","content":"Codecademy HTML 教程学习笔记\n\nHeadings（标题）HTML 中一共有六种不同的标题和标题元素，一下为 HTML 中可用的标题元素，按等级降序排列：\n\n&lt;h1&gt; —— 主标题，其余小标题均为次级标题。\n&lt;h2&gt;\n&lt;h3&gt;\n&lt;h4&gt;\n&lt;h5&gt;\n&lt;h6&gt;\n\n\n下面的例子为主标题的使用：\n&lt;h1&gt;BREAKING NEWS&lt;&#x2F;h1&gt;\n\nDivs&lt;div&gt; 为 HTML 中的常用元素之一。&lt;div&gt; 为单词“division”的简写，也可称为将页面分为不同章节的容器。\n&lt;body&gt;\n  &lt;div&gt;\n    &lt;h1&gt;Why use divs?&lt;&#x2F;h1&gt;\n    &lt;p&gt;Great for grouping elements!&lt;&#x2F;p&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n\n&lt;div&gt; 中可包含各种文本以及 HTML 元素，例如链接、图片或者视频。为保证可读性，在 &lt;div&gt; 中嵌套元素时请务必在每行添加两空格缩进。\nAttributes（属性）使用属性展开元素标签。属性是加在元素开始标识符中的一段文字，可以用于说明元素的信息以及变换格式。属性有以下2部分组成：\n\n属性名称\n属性值\n\nid 为常用的一个属性。如果要多次使用同一种元素的话（如 &lt;div&gt;），可以使用该属性区分该元素中包含的内容。除此之外，id 还具备其他功能。\n当要给 &lt;div&gt; 添加 id 时，应将其插入开始标识符中：\n&lt;div id&#x3D;&quot;intro&quot;&gt;\n  &lt;h1&gt;Introduction&lt;&#x2F;h1&gt;\n&lt;&#x2F;div&gt;\n\nDisplaying Text（显示文字）使用段落或者范围元素，以在 HTML 中显示文本。\n\n段落（&lt;p&gt;）包含一段纯文本。\n&lt;span&gt; 包含一小段文本或其他 HTML 内容，一般用于在同一行中将一部分内容与其他内容区分开。\n\n例如：\n&lt;div&gt;\n  &lt;h1&gt;Technology&lt;&#x2F;h1&gt;\n&lt;&#x2F;div&gt;\n&lt;div&gt;\n  &lt;p&gt;&lt;span&gt;Self-driving cars&lt;&#x2F;span&gt; are anticipated to replace up to 2 million jobs over the next two decades.&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;\n\n如前述，第二个 &lt;div&gt; 中包含了一个 &lt;p&gt; 以及其子元素 &lt;span&gt;Self-driving cars&lt;/span&gt;，此处 &lt;span&gt; 元素的作用即是将“Self-driving cars”与此段中的其他文字区分开。\n&lt;span&gt; 适用于将一段文字嵌入到段落中，若要将文字分割成不同段落，最好使用 &lt;div&gt;。\n","slug":"HTML-动手学（2）","date":"2019-05-26T02:52:31.000Z","categories_index":"动手学,HTML","tags_index":"动手学,HTML,前端开发","author_index":"Ryanhui"},{"id":"5422a3fb710d74bb991f64a2009371d0","title":"HTML 动手学（1）","content":"Codecademy HTML 教程学习笔记\n\n何谓 HTMLHTML (HyperText Markup Language):\n\nMarkup 语言为定义纯文本结构以及版式的编程语言。\n计算机可以解读 HTML 元素中的纯文本。\nHyperText（超文本）为可链接到其他文本的文字，也被称为 hyperlinks（超链接）。\n\n学习 HTML 是建立个人网站的第一步，本次仅涉及添加和修改网页上的基本内容，包括文本、图片以及视频。\nHTML 注释HTML 是由各种元素构成的，这些元素构成了网页以及定义了其中的内容。\n下图为 HTML 段落元素的结构，它由一个 opening tag &lt;p&gt;，文本内容 “Hello World!”，以及一个 closing tag &lt;/p&gt; 组成。一个 tag 及其里面的内容即称为 HTML 元素。除此之外，还有其他用于组织和展示文本以及其他内容（如图片）的标识符。\n\n上图中组成元素的各个部分：\n\nHTML 元素（简称“元素”）—— HTML 文本中内容的单位，由 HTML 标识符以及其中的内容组成。\nHTML 标识符 —— 元素名称，用箭头括号 &lt;&gt; 括起来的部分。\n开始标识符 —— 第一个 HTML 标识符，标志一个 HTML 元素的开始，用箭头括号 &lt;&gt; 括起来。\n内容 —— 夹在开始与结束标识符中的信息（文本或其他元素）。\n结束标识符 —— 第二个 HTML 标识符，标志一个 HTML 元素的结束。结束标识符在左箭头括号后面要跟随一个斜线 /。\n\nThe Body搭建网站中最重要的一个 HTML 元素为 body 元素，只有包含在 body 标识符中的内容才能被显示出来，其形式为：\n&lt;body&gt;\n\n&lt;&#x2F;body&gt;\n\n有了 body 之后，其他类型的内容（文本，图片和按钮等）才能添加到 body 中。\n&lt;body&gt;\n  &lt;p&gt;What&#39;s up, doc?&lt;&#x2F;p&gt;\n&lt;&#x2F;body&gt;\n\nHTML 结构HTML 由家族树关系构成。当一个元素包含到另一个元素中时，前者称为后者的子元素。子元素被称为嵌套在父元素中。\n&lt;body&gt;\n  &lt;p&gt;This paragraph is a child of the body&lt;&#x2F;p&gt;\n&lt;&#x2F;body&gt;\n\n在上述例子中，&lt;p&gt; 元素嵌套在 &lt;body&gt; 元素中。&lt;p&gt; 元素是 &lt;body&gt; 元素的子元素，&lt;body&gt; 元素是 &lt;p&gt; 元素的父元素。为增加代码的可读性，可以加2格空格缩进。\n由于可以有多层嵌套，因此可以衍生出次子元素、次次子元素等等。祖先元素和子元素的关系称为层次结构（hierarchy）。\n看如下的例子：\n&lt;body&gt;\n  &lt;div&gt;\n    &lt;h1&gt;Sibling to p, but also grandchild of body&lt;&#x2F;h1&gt;\n    &lt;p&gt;Sibling to h1, but also grandchild of body&lt;&#x2F;p&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n\n这个例子中，&lt;body&gt; 元素是 &lt;div&gt; 元素的父元素。&lt;p&gt; 元素和 &lt;h1&gt; 元素同是 &lt;div&gt; 元素的子元素。\n理解 HTML 的层次结构十分必要，因为子元素可以继承其父元素的特征以及格式。\n","slug":"HTML-动手学（1）","date":"2019-05-25T08:51:39.000Z","categories_index":"动手学,HTML","tags_index":"动手学,HTML,前端开发","author_index":"Ryanhui"},{"id":"30ff94be16f3004704f0b1e90b7e7d30","title":"python 数据分析动手学 with Pandas","content":"\n\n\n\n\n\n\n\n\n头发苦短，我用python\n使用 Python 的 Pandas 类库实现了对国家统计局地区统计数据的自动整理，快速对接到动态排名数据可视化模板。\n\n必要开发环境\nPython 3.7.3\nPandas\nNumpy\n\n准备工作安装软件安装 Pandas 第三类库，在终端输入指令\npip install pandas\n\n由于 Pandas 基于 Numpy，因此执行上述指令时将自动安装 Numpy。\n获取数据大数据的获取一般分两种手段：网络直接下载和爬虫。前者较为简单，但能够获取的数据量有限，且有时需要资金投入。后者学习门槛较高，但可获取的数据面广泛。本次以国家统计局统计的近20年各地区年生产总值为例，实现数据快速分析整理。\n进入国家数据，点击地区数据下的分省年度数据。\n\n选择指标“地区生产总值”。\n\n点击下载，选择 csv 格式。\n\n打开下载好的 csv 文件，格式如下。\n数据库：分省年度数据\n指标：地区生产总值(亿元)\n时间：最近20年\n地区,2018年,2017年,2016年,2015年,2014年,2013年,2012年,2011年,2010年,2009年,2008年,2007年,2006年,2005年,2004年,2003年,2002年,2001年,2000年,1999年\n北京市,,28014.94,25669.13,23014.59,21330.83,19800.81,17879.40,16251.93,14113.58,12153.03,11115.00,9846.81,8117.78,6969.52,6033.21,5007.21,4315.00,3707.96,3161.66,2678.82\n天津市,,18549.19,17885.39,16538.19,15726.93,14442.01,12893.88,11307.28,9224.46,7521.85,6719.01,5252.76,4462.74,3905.64,3110.97,2578.03,2150.76,1919.09,1701.88,1500.95\n河北省,,34016.32,32070.45,29806.11,29421.15,28442.95,26575.01,24515.76,20394.26,17235.48,16011.97,13607.32,11467.60,10012.11,8477.63,6921.29,6018.28,5516.76,5043.96,4514.19\n...\n青海省,,2624.83,2572.49,2417.05,2303.32,2122.06,1893.54,1670.44,1350.43,1081.27,1018.62,797.35,648.50,543.32,466.10,390.20,340.65,300.13,263.68,239.38\n宁夏回族自治区,,3443.56,3168.59,2911.77,2752.10,2577.57,2341.29,2102.21,1689.65,1353.31,1203.92,919.11,725.90,612.61,537.11,445.36,377.16,337.44,295.02,264.58\n新疆维吾尔自治区,,10881.96,9649.70,9324.80,9273.46,8443.84,7505.31,6610.05,5437.47,4277.05,4183.21,3523.16,3045.26,2604.19,2209.09,1886.35,1612.65,1491.60,1363.56,1163.17\n&quot;注：本表按当年价格计算。2004年以前地区生产总值数据执行《国民经济行业分类》（GB&#x2F;T4754-1994），2004-2012年地区生产总值数据执行《国民经济行业分类》（GB&#x2F;T4754-2002）,三次产业划分根据《三次产业划分规定》（2003）。2013年开始，行业分类执行《国民经济行业分类》（GB&#x2F;T4754-2011），三次产业划分根据《三次产业划分规定》（2012）。&quot;\n数据来源：国家统计局\n\n可见原始格式很难满足我们的要求，因此下一步将使用 python 将该数据表整理为我们需要的格式。\n数据整理导入 csv 文件使用 Pandas 中的 read_csv() 函数读入 csv 文件，如：\nimport pandas as pd\nimport numpy as np\n\ns_data &#x3D; pd.read_csv(&#39;test.csv&#39;, skiprows &#x3D; 3, encoding &#x3D; &#39;utf-8&#39;)\n\n参数说明：\n\nfilepath_or_buffer - 读取文件路径，可以是URL，可用URL类型包括：http, ftp, s3。\nskiprows - 需要忽略的行数（从文件开始处算起），或需要跳过的行号列表（从0开始）。此处需删除前三行表头，设置 skiprows = 3。\nskipfooter - 从文件尾部开始忽略。 (c引擎不支持)\nencoding - 指定字符集类型，通常指定为’utf-8’。List of Python standard encodings\n\n其余参数详解\n整理原始数据使用 dropna() 函数删除空行与空列，函数形式为：\nDataFrame.dropna(axis&#x3D;0, how&#x3D;&#39;any&#39;, thresh&#x3D;None, subset&#x3D;None, inplace&#x3D;False)\n\n参数说明：\n\naxis\naxis=0: 删除包含缺失值的行\naxis=1: 删除包含缺失值的列\n\n\nhow: 与axis配合使用\nhow=’any’ :只要有缺失值出现，就删除该行货列\nhow=’all’: 所有的值都缺失，才删除行或列\n\n\nthresh： axis中至少有thresh个非缺失值，否则删除。比如 axis=0，thresh=10：标识如果该行中非缺失值的数量小于10，将删除改行。\nsubset: list，在哪些列中查看是否有缺失值\ninplace: 是否在原数据上操作。如果为真，返回None否则返回新的copy，去掉了缺失值\n\n此处需要删除没有统计数据的2018年，以及表格底部的说明。\ns_data &#x3D; s_data.dropna(axis&#x3D;1, how&#x3D;&#39;all&#39;) #删除空列（未统计年份）\ns_data &#x3D; s_data.dropna(axis&#x3D;0, how&#x3D;&#39;any&#39;) #删除空行（底部说明）\n\n转置表格，方便下一步处理。\ns_data &#x3D; s_data.T\n\n将数据写入目标格式动态排名数据可视化模板要求的数据格式为：\n\n\n\nname\ntype\nvalue\ndate\n\n\n\n名称1\n类型1\n值1\n日期1\n\n\n名称2\n类型2\n值2\n日期2\n\n\n其中“名称”会出现在柱状图的左侧作为Y轴，而“类型-名称”会作为附加信息出现在柱状图上。类型与柱状图的颜色相关，建议命名为不包含空格或者特殊符号的中英文字符。值与柱状图的长度绑定，必须是整数或浮点数。日期建议使用的格式为”YYYY-MM-DD”。\n新建一个空 DataFrame 数据表以储存输出的数据，其列索引为 [&#39;name&#39;,&#39;type&#39;,&#39;value&#39;,&#39;date&#39;]。\no_data &#x3D; pd.DataFrame(columns &#x3D; [&#39;name&#39;,&#39;type&#39;,&#39;value&#39;,&#39;date&#39;])\n\n同时新建一个名为 temp 的空数据表，其行数与 o_data 相同，而列数为统计省份的数量。\ntemp &#x3D; pd.DataFrame(columns &#x3D; [&#39;name&#39;,&#39;type&#39;,&#39;value&#39;,&#39;date&#39;], index &#x3D; np.arange(0,s_data.shape[1]))\n\n其中，s_data.shape[1] 为原始数据表的列数\n遍历一年中个省份的地方生产总值，并分别写到 temp 个对应位置中，将各年数据合并至 o_data 中即可。\n实现代码：\nfor i in range(1,len(s_data)):\n    for j in range(0,s_data.shape[1]):\n        temp.iloc[j][&#39;name&#39;] &#x3D; s_data.loc[&#39;地区&#39;][j]    #将地区名写入 name 列\n        temp.iloc[j][&#39;type&#39;] &#x3D; s_data.index[0]      #将“地区”写入 type 列（可省略）\n        temp.iloc[j][&#39;value&#39;] &#x3D; s_data.iloc[i][j]       #将对应生产总值写入 value 列\n        temp.iloc[j][&#39;date&#39;] &#x3D; s_data.index[i]      #将对应年份写入 date 列\n    o_data &#x3D; pd.concat([o_data,temp],ignore_index&#x3D;True)     #将各年数据整合到输出表格中\n\nlen(s_data) 为原始数据表的行数。索引 DataFrame 中特定元素值由两种方法：\n\ndf.iloc - 根据元素位置；\ndf.loc - 根据行索引。\n\n使用 pd.concat() 将两个数据表格按先后顺序合并，将 ignore_index 打开。\n整理输出数据输出的数据表格中年份是按照降序排列的，直接导入可视化模板的话将按时间倒序展示，故使用 sort_values() 函数对表格数据重新排列，其形式如下：\nDataFrame.sort_values(by, axis&#x3D;0, ascending&#x3D;True, inplace&#x3D;False, kind&#x3D;&#39;quicksort&#39;, na_position&#x3D;&#39;last&#39;)\n\n参数说明：\n\n使用 sort_values() 函数时要注意，默认的 inplace 设置是 False ，并没有对本体进行覆盖，可能会导致排序不成功的问题。此时需要设置 inplace=True，或者手动赋值给输出变量。\n对 o_data 中的 date 列进行升序排序：\no_data &#x3D; o_data.sort_values(by&#x3D; [&#39;date&#39;], ascending&#x3D; True) #对年份重新排序\n\n导出 csv 文件关闭行索引，以 utf-8 格式导出到 csv 文件。\no_data.to_csv(&#39;output.csv&#39;, encoding &#x3D; &#39;utf-8&#39;, index&#x3D; False )\n\n注意 to_csv() 是 DataFrame 类的方法，read_csv() 是 pandas 的方法。\n","slug":"python数据分析动手学-with-Pandas","date":"2019-05-07T13:52:18.000Z","categories_index":"动手学,Python","tags_index":"动手学,python,Pandas,数据分析","author_index":"Ryanhui"},{"id":"7d18f3855f6cc8b1847f13a641a0f28b","title":"Markdown 动手学","content":"Markdown 语法练习\n\n段落、标题、区块代码A Second Level HeaderNow is the time for all good men to come tothe aid of their country. This is just aregular paragraph.\nThe quick brown fox jumped over the lazydog’s back.\nHeader 3\n\n\n\n\n\n\n\n\nThis is a blockquote.\nThis is the second paragraph in the blockquote.\nThis is an H2 in a blockquote\n修辞和强调Some of these words are emphasized.Some of these words are emphasized also.Use two asterisks for strong emphasis.Or, if you prefer, use two underscores instead.\n列表无序列表\nCandy.\nGum.\nBooze.\n\n\nCandy.\nGum.\nBooze.\n\n\nCandy.\nGum.\nBooze.\n\n有序列表\nRed\nGreen\nBlue\n\n\nA list item.With multiple paragraphs.\n\nAnother item in the list.\n\n\n链接This is an example link.\nThis is an example link.\nI get 10 times more traffic from Google than fromYahoo or MSN.\nI start my morning with a cup of coffee andThe New York Times.\n图片（title 是选择性的）\n\n代码I strongly recommend against using any &lt;blink&gt; tags.\nI wish SmartyPants used named entities like &amp;mdash;instead of decimal-encoded entites like &amp;#8212;.\nIf you want your page to validate under XHTML 1.0 Strict,you’ve got to put paragraph tags in your blockquotes:\n\nFor example.\n\n视频与音乐插入音乐\n\n\n插入视频\n \n","slug":"Markdown快速上手","date":"2019-04-25T16:00:00.000Z","categories_index":"动手学","tags_index":"动手学","author_index":"Ryanhui"}]